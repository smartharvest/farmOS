{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"farmOS 2.x \u00b6 ATTENTION: This documentation is for the 2.x branch of farmOS, which is under active development. If you want to use farmOS, the recommended stable branch is 7.x-1.x. farmOS 1.x documentation is available at http://farmOS.org .","title":"farmOS 2.x"},{"location":"#farmos-2x","text":"ATTENTION: This documentation is for the 2.x branch of farmOS, which is under active development. If you want to use farmOS, the recommended stable branch is 7.x-1.x. farmOS 1.x documentation is available at http://farmOS.org .","title":"farmOS 2.x"},{"location":"development/api/","text":"API \u00b6 farmOS provides an API that other applications/systems can use to read and write records via HTTP requests. The root API endpoint is /api . farmOS adheres to the JSON:API specification, and JSON Schema is used to describe the available API resources. To begin exploring the farmOS API schema, visit /api/schema . From there, you can traverse a graph of interconnected schemas describing the entire API.","title":"Introduction"},{"location":"development/api/#api","text":"farmOS provides an API that other applications/systems can use to read and write records via HTTP requests. The root API endpoint is /api . farmOS adheres to the JSON:API specification, and JSON Schema is used to describe the available API resources. To begin exploring the farmOS API schema, visit /api/schema . From there, you can traverse a graph of interconnected schemas describing the entire API.","title":"API"},{"location":"development/api/authentication/","text":"Authentication \u00b6 farmOS includes an OAuth2 Authorization server for providing 1st and 3rd party clients access to the farmOS API. Rather than using a user's username and password to both authorize and authenticate a request, OAuth2 requires users to complete an authorization flow that generates an access_token to be used for authentication. Access tokens are provided to both 1st and 3rd party clients who wish to access the server's protected resources. Clients store the access token instead of the user's credentials, which makes it a more secure authentication method. Read more about the OAuth 2.0 standards . Client Libraries \u00b6 The farmOS.py and farmOS.js client libraries use the OAuth2 protocol to interact with the farmOS API. OAuth2 Bearer Tokens \u00b6 Once you have an OAuth2 token, you can authenticate requests to the farmOS server by including an Authentication: Bearer {access_token} header. OAuth2 Details \u00b6 The OAuth protocol defines a process where users authorize 1st and 3rd party clients with scoped access to data on the server. The following describes the details necessary for using OAuth2 authorization with a farmOS server. Scopes \u00b6 OAuth Scopes define different levels of permission. The farmOS server implements scopes as roles associated with OAuth clients. This means that users will authorize clients with roles that determine how much access they have to data on the server. Clients \u00b6 An OAuth Client represents a 1st or 3rd party integration with the farmOS server. Clients are uniquely identified by a client_id and are configured to use different scopes . The core farm_api module provides a default client with client_id = farm . If you are writing a script that communicates with your farmOS server via the API, you should use this client to authorize access and generate an access_token for authentication. If you are creating a third party integration with farmOS, see the OAuth page of the farmOS module development docs for steps to create an OAuth Client. Authorization Flows \u00b6 The OAuth 2.0 standards outline 5 Oauth2 Grant Types to be used in an OAuth2 Authorization Flow - They are the Authorization Code, Implicit, Password Credentials, Client Credentials and Refresh Token Grants. The Authorization Code and Refresh Token grants are the only Authorization Flows recommended by farmOS for use with 3rd party clients. NOTE: Only use the Password Grant if the client can be trusted with a farmOS username and password (this is considered 1st party ). The Client Credentials Grant is often used for machine authentication not associated with a user account. The client credentials grant should only be used if a client_secret can be kept secret. If connecting to multiple farmOS servers, each server should use a different secret. This is challenging due to the nature of farmOS being a self-hosted application. Authorization Code Grant \u00b6 The Authorization Code Grant is most popular for 3rd party client authorization. Requesting resources is a four step process: First : the client sends a request to the farmOS server /oauth/authorize endpoint requesting an Authorization Code . The user logs in and authorizes the client to have the OAuth Scopes it is requesting. Copy this link to browser - http://localhost/oauth/authorize?response_type=code&client_id=farmos_development&scope=user_access&redirect_uri=http://localhost/api/authorized&state=p4W8P5f7gJCIDbC1Mv78zHhlpJOidy Second : after the user accepts, the server redirects to the redirect_uri with an authorization code and state in the query parameters. Example redirect url from server: http://localhost/api/authorized?code=9eb9442c7a2b011fd59617635cca5421cd089943&state=p4W8P5f7gJCIDbC1Mv78zHhlpJOidy Third : copy the code and state from the URL into the body of a POST request. The grant_type , client_id , client_secret and redirect_uri must also be included in the POST body. The client makes a POST request to the /oauth/token endpoint to retrieve an access_token and refresh_token . foo@bar:~$ curl -X POST -d \"grant_type=authorization_code&code=ae4d1381cc67def1c10dc88a19af6ac30d7b5959&client_id=farmos_development&redirect_uri=http://localhost/api/authorized\" http://localhost/oauth/token {\"access_token\":\"3f9212c4a6656f1cd1304e47307927a7c224abb0\",\"expires_in\":\"10\",\"token_type\":\"Bearer\",\"scope\":\"user_access\",\"refresh_token\":\"292810b04d688bfb5c3cee28e45637ec8ef1dd9e\"} Fourth : the client sends the access token in the request header to access protected resources. The header is an Authorization header with a Bearer token: Authorization: Bearer access_token foo@bar:~$ curl --header \"Authorization: Bearer b872daf5827a75495c8194c6bfa4f90cf46c143e\" http://localhost/farm.json {\"name\":\"farmos-server\",\"url\":\"http:\\/\\/localhost\",\"api_version\":\"1.1\",\"user\":{\"uid\":\"1\",\"name\":\"admin\", .... Password Credentials Grant \u00b6 NOTE: Only use the Password Grant if the client can be trusted with a farmOS username and password (this is considered 1st party ). The Password Credentials Grant uses a farmOS username and password to retrieve an access_token and refresh_token in one step. For the user, this is the simplest type of authorization. Because the client can be trusted with their farmOS Credentials, a users username and password can be collected directly into a login form within the client application. These credentials are then used (not stored) to request tokens which are used for authentication with the farmOS server and retrieving data. Requesting protected resources is a two step process: First , the client sends a POST request to the farmOS server /oauth/token endpoint with grant_type set to password and a username and password included in the request body. $ curl -X POST -d \"grant_type=password&username=username&password=test&client_id=farm&scope=user_access\" http://localhost/oauth/token {\"access_token\":\"e69c60dea3f5c59c95863928fa6fb860d3506fe9\",\"expires_in\":\"300\",\"token_type\":\"Bearer\",\"scope\":\"user_access\",\"refresh_token\":\"cead7d46d18d74daea83f114bc0b512ec4cc31c3\"} second , the client sends the access_token in the request header to access protected resources. The header is an Authorization header with a Bearer token: Authorization: Bearer access_token foo@bar:~$ curl --header \"Authorization: Bearer e69c60dea3f5c59c95863928fa6fb860d3506fe9\" http://localhost/farm.json {\"name\":\"farmos-server\",\"url\":\"http:\\/\\/localhost\",\"api_version\":\"1.1\",\"user\":{\"uid\":\"1\",\"name\":\"admin\", .... Refreshing Tokens \u00b6 The refresh_token can be used to retrieve a new access_token if the token has expired. It is a one step process: The client sends an authenticated request to the /oauth/token endpoint with grant_type set to refresh_token and includes the refresh_token , client_id and client_secret in the request body. foo@bar:~$ curl -X POST -H 'Authorization: Bearer ad52c04d26c1002084501d28b59196996f0bd93f' -d 'refresh_token=52e7a0e12e8ddd08b155b3b3ee385687fef01664&grant_type=refresh_token&client_id=farmos_api_client&client_secret=client_secret' http://localhost/oauth/token {\"access_token\":\"acdbfabb736e42aa301b50fdda95d6b7fd3e7e14\",\"expires_in\":\"300\",\"token_type\":\"Bearer\",\"scope\":\"user_access\",\"refresh_token\":\"b73f4744840498a26f43447d8cf755238bfd391a\"} The server responds with an access_token and refresh_token that can be used in future requests. The previous access_token and refresh_token will no longer work.","title":"Authentication"},{"location":"development/api/authentication/#authentication","text":"farmOS includes an OAuth2 Authorization server for providing 1st and 3rd party clients access to the farmOS API. Rather than using a user's username and password to both authorize and authenticate a request, OAuth2 requires users to complete an authorization flow that generates an access_token to be used for authentication. Access tokens are provided to both 1st and 3rd party clients who wish to access the server's protected resources. Clients store the access token instead of the user's credentials, which makes it a more secure authentication method. Read more about the OAuth 2.0 standards .","title":"Authentication"},{"location":"development/api/authentication/#client-libraries","text":"The farmOS.py and farmOS.js client libraries use the OAuth2 protocol to interact with the farmOS API.","title":"Client Libraries"},{"location":"development/api/authentication/#oauth2-bearer-tokens","text":"Once you have an OAuth2 token, you can authenticate requests to the farmOS server by including an Authentication: Bearer {access_token} header.","title":"OAuth2 Bearer Tokens"},{"location":"development/api/authentication/#oauth2-details","text":"The OAuth protocol defines a process where users authorize 1st and 3rd party clients with scoped access to data on the server. The following describes the details necessary for using OAuth2 authorization with a farmOS server.","title":"OAuth2 Details"},{"location":"development/api/authentication/#scopes","text":"OAuth Scopes define different levels of permission. The farmOS server implements scopes as roles associated with OAuth clients. This means that users will authorize clients with roles that determine how much access they have to data on the server.","title":"Scopes"},{"location":"development/api/authentication/#clients","text":"An OAuth Client represents a 1st or 3rd party integration with the farmOS server. Clients are uniquely identified by a client_id and are configured to use different scopes . The core farm_api module provides a default client with client_id = farm . If you are writing a script that communicates with your farmOS server via the API, you should use this client to authorize access and generate an access_token for authentication. If you are creating a third party integration with farmOS, see the OAuth page of the farmOS module development docs for steps to create an OAuth Client.","title":"Clients"},{"location":"development/api/authentication/#authorization-flows","text":"The OAuth 2.0 standards outline 5 Oauth2 Grant Types to be used in an OAuth2 Authorization Flow - They are the Authorization Code, Implicit, Password Credentials, Client Credentials and Refresh Token Grants. The Authorization Code and Refresh Token grants are the only Authorization Flows recommended by farmOS for use with 3rd party clients. NOTE: Only use the Password Grant if the client can be trusted with a farmOS username and password (this is considered 1st party ). The Client Credentials Grant is often used for machine authentication not associated with a user account. The client credentials grant should only be used if a client_secret can be kept secret. If connecting to multiple farmOS servers, each server should use a different secret. This is challenging due to the nature of farmOS being a self-hosted application.","title":"Authorization Flows"},{"location":"development/api/authentication/#authorization-code-grant","text":"The Authorization Code Grant is most popular for 3rd party client authorization. Requesting resources is a four step process: First : the client sends a request to the farmOS server /oauth/authorize endpoint requesting an Authorization Code . The user logs in and authorizes the client to have the OAuth Scopes it is requesting. Copy this link to browser - http://localhost/oauth/authorize?response_type=code&client_id=farmos_development&scope=user_access&redirect_uri=http://localhost/api/authorized&state=p4W8P5f7gJCIDbC1Mv78zHhlpJOidy Second : after the user accepts, the server redirects to the redirect_uri with an authorization code and state in the query parameters. Example redirect url from server: http://localhost/api/authorized?code=9eb9442c7a2b011fd59617635cca5421cd089943&state=p4W8P5f7gJCIDbC1Mv78zHhlpJOidy Third : copy the code and state from the URL into the body of a POST request. The grant_type , client_id , client_secret and redirect_uri must also be included in the POST body. The client makes a POST request to the /oauth/token endpoint to retrieve an access_token and refresh_token . foo@bar:~$ curl -X POST -d \"grant_type=authorization_code&code=ae4d1381cc67def1c10dc88a19af6ac30d7b5959&client_id=farmos_development&redirect_uri=http://localhost/api/authorized\" http://localhost/oauth/token {\"access_token\":\"3f9212c4a6656f1cd1304e47307927a7c224abb0\",\"expires_in\":\"10\",\"token_type\":\"Bearer\",\"scope\":\"user_access\",\"refresh_token\":\"292810b04d688bfb5c3cee28e45637ec8ef1dd9e\"} Fourth : the client sends the access token in the request header to access protected resources. The header is an Authorization header with a Bearer token: Authorization: Bearer access_token foo@bar:~$ curl --header \"Authorization: Bearer b872daf5827a75495c8194c6bfa4f90cf46c143e\" http://localhost/farm.json {\"name\":\"farmos-server\",\"url\":\"http:\\/\\/localhost\",\"api_version\":\"1.1\",\"user\":{\"uid\":\"1\",\"name\":\"admin\", ....","title":"Authorization Code Grant"},{"location":"development/api/authentication/#password-credentials-grant","text":"NOTE: Only use the Password Grant if the client can be trusted with a farmOS username and password (this is considered 1st party ). The Password Credentials Grant uses a farmOS username and password to retrieve an access_token and refresh_token in one step. For the user, this is the simplest type of authorization. Because the client can be trusted with their farmOS Credentials, a users username and password can be collected directly into a login form within the client application. These credentials are then used (not stored) to request tokens which are used for authentication with the farmOS server and retrieving data. Requesting protected resources is a two step process: First , the client sends a POST request to the farmOS server /oauth/token endpoint with grant_type set to password and a username and password included in the request body. $ curl -X POST -d \"grant_type=password&username=username&password=test&client_id=farm&scope=user_access\" http://localhost/oauth/token {\"access_token\":\"e69c60dea3f5c59c95863928fa6fb860d3506fe9\",\"expires_in\":\"300\",\"token_type\":\"Bearer\",\"scope\":\"user_access\",\"refresh_token\":\"cead7d46d18d74daea83f114bc0b512ec4cc31c3\"} second , the client sends the access_token in the request header to access protected resources. The header is an Authorization header with a Bearer token: Authorization: Bearer access_token foo@bar:~$ curl --header \"Authorization: Bearer e69c60dea3f5c59c95863928fa6fb860d3506fe9\" http://localhost/farm.json {\"name\":\"farmos-server\",\"url\":\"http:\\/\\/localhost\",\"api_version\":\"1.1\",\"user\":{\"uid\":\"1\",\"name\":\"admin\", ....","title":"Password Credentials Grant"},{"location":"development/api/authentication/#refreshing-tokens","text":"The refresh_token can be used to retrieve a new access_token if the token has expired. It is a one step process: The client sends an authenticated request to the /oauth/token endpoint with grant_type set to refresh_token and includes the refresh_token , client_id and client_secret in the request body. foo@bar:~$ curl -X POST -H 'Authorization: Bearer ad52c04d26c1002084501d28b59196996f0bd93f' -d 'refresh_token=52e7a0e12e8ddd08b155b3b3ee385687fef01664&grant_type=refresh_token&client_id=farmos_api_client&client_secret=client_secret' http://localhost/oauth/token {\"access_token\":\"acdbfabb736e42aa301b50fdda95d6b7fd3e7e14\",\"expires_in\":\"300\",\"token_type\":\"Bearer\",\"scope\":\"user_access\",\"refresh_token\":\"b73f4744840498a26f43447d8cf755238bfd391a\"} The server responds with an access_token and refresh_token that can be used in future requests. The previous access_token and refresh_token will no longer work.","title":"Refreshing Tokens"},{"location":"development/api/changes/","text":"API Changes \u00b6 2.x vs 1.x \u00b6 farmOS 1.x used the RESTful Web Services module, which provided API endpoints for each entity type (asset, log, taxonomy term, etc). farmOS 2.x uses the new JSON:API module included with Drupal core, which follows the JSON:API specification for defining API resources. The root API endpoint is /api . JSON Schema \u00b6 farmOS 2.x also provides JSON Schema information about all available resources. The root endpoint for schema information is /api/schema . In farmOS 1.x, the /farm.json endpoint provided similar information in the resources property. This has been removed in favor of JSON Schema. Authentication \u00b6 See API Authentication for more information about authorizing and authenticating farmOS 2.x API requests. Notable changes from 1.x include: The new authorization URL is /oauth/authorize (was /oauth2/authorize ). The new token URL is /oauth/token (was /oauth2/token ). Requests should use Content-Type: application/vnd.api+json (was Content-Type: application/json ). Farm info endpoint \u00b6 In farmOS 1.x, an informational API endpoint was provided at /farm.json . This included various information describing the farmOS server configuration, authenticated user, installed languages and available entity types and bundles. This information was provided as either a simple value or a JSON object: { \"name\": \"My Farm\", \"url\": \"https://myfarm.mydomain.com\", \"api_version\": \"1.0\", \"system_of_measurement\": \"metric\", \"user\": { ... }, \"languages\": { ... }, \"resources\": { ... }, \"metrics\": { ... } } In farmOS 2.x, a root /api endpoint either provides this information, or is a gateway to this information. The simple values previously available from /farm.json are now provided in the meta.farm object at /api : { \"jsonapi\":{ ... }, \"data\":[], \"meta\":{ \"links\":{ \"me\":{ \"meta\":{ \"id\":\"7b2af019-3191-40ca-b221-616f9a365722\" }, \"href\":\"http://localhost/api/user/user/7b2af019-3191-40ca-b221-616f9a365722\" } }, \"farm\":{ \"name\":\"My farm name\", \"url\":\"http://localhost\", \"version\":\"2.x\", \"system_of_measurement\": \"metric\" } }, \"links\":{ ... } } The resources object has been replaced with the links object that describes all the available resource types and their endpoints. Information previously provided in the other JSON objects are now available as standalone resources at their respective endpoints: user - /api/user/user The authenticated user's ID is included in the meta.links.me object with a link to the user's resource. The user's attributes, such as name and language, can be retrieved from that endpoint. languages - /api/configurable_language/configurable_language Resource endpoints \u00b6 In farmOS 1.x, API endpoints for each entity type were available at /[entity_type].json . For example: /log.json In farmOS 2.x, a root /api endpoint is provided, with a links object that describes all the available resource types and their endpoints. These follow a URL pattern of /api/[entity-type]/[bundle] . For example: /api/log/activity \"Bundles\" are \"sub-types\" that can have different sets (bundles) of fields on them. For example, a \"Seeding Log\" and a \"Harvest Log\" will collect different information, but both are \"Logs\" (events). To illustrate the difference between 1.x and 2.x, here are the endpoints for retrieving all Activity logs. farmOS 1.x: /log.json?type=farm_activity farmOS 2.x: /api/log/activity IDs \u00b6 farmOS 2.x assigns UUIDs (universally unique identifiers) to all resources, and uses them in the API. This differs from farmOS 1.x, which used the integer IDs directly from the auto-incrementing database table that the record was pulled from. The benefit of UUIDs is they are guaranteed to be unique across multiple farmOS databases, whereas the old IDs were not. The internal integer IDs are not exposed via the API, so all code that needs to integrate should use the new UUIDs instead. Also note that the migration from farmOS 1.x to 2.x does not preserve the internal integer IDs, so they may be different after migrating to 2.x. Record structure \u00b6 JSON:API has some rules about how records are structured that differ from farmOS 1.x. These rules make the API more explicit. In farmOS 1.x, all the fields/properties of a record were on the same level. For example, a simple observation log looked like this: { \"id\": \"5\" \"type\": \"farm_observation\", \"name\": \"Test observation\", \"timestamp\": \"1526584271\", \"asset\": [ { \"resource\": \"farm_asset\", \"id\": \"123\" } ] } In farmOS 2.x, JSON:API dictates that the \"attributes\" and \"relationships\" of a record be explicitly declared under attributes and relationships properties in the JSON. The same record in farmOS 2.x looks like: { \"id\": \"9bc49ffd-76e8-4f86-b811-b721cb771327\" \"type\": \"log--observation\", \"attributes\": { \"name\": \"Test observation\", \"timestamp\": \"1526584271\", }, \"relationships\": { \"asset\": { \"data\": [ { \"type\": \"asset--animal\", \"id\": \"75116e3e-c45e-431d-8b58-1fce6bb315cf\", } ] } } } Filtering \u00b6 The URL query parameters for filtering results have a different syntax in 2.x. Refer to the Drupal.org JSON:API Filtering documentation for more information. To illustrate, this is how to filter activity logs by their completed status: farmOS 1.x: /log.json?type=activity&done=1 farmOS 2.x: /api/log/activity?filter[status]=complete Text format \u00b6 Long text fields (like notes ) include value and format sub-properties, where value is the text value, and format is the \"Text format\" to use when displaying the text. This is used to filter user-supplied text, to only allow certain HTML tags (filtering out potential XSS vulnerabilities), convert URLs to links, etc. This works the same in farmOS 2.x, but the default format has changed from farm_format to default . Logs \u00b6 Log types \u00b6 The farm_ prefix has been dropped from all log type names. For example, in farmOS 1.x an Activity log was farm_activity , and in farmOS 2.x it is simply activity . Additionally, the \"Soil test\" and \"Water test\" log types have been merged into a single \"Lab test\" log type. Below is the full list of log types in farmOS 1.x and their new names in 2.x: farm_activity -> activity farm_harvest -> harvest farm_input -> input farm_maintenance -> maintenance farm_medical -> medical farm_observation -> observation farm_purchase -> purchase farm_sale -> sale farm_seeding -> seeding farm_soil_test -> lab_test farm_transplanting -> transplanting farm_water_test -> lab_test Log fields \u00b6 Log field names are largely unchanged, with a few exceptions (note that new fields are not listed here): area -> location (See \"Areas\" below) date_purchase -> purchase_date done -> status (see \"Log status\" below) files -> file flags -> flag geofield -> geometry images -> image input_method -> method input_source -> source inventory (merged into quantity entities) log_category -> category log_owner -> owner seed_source -> source soil_lab -> lab water_lab -> lab quantity (see \"Quantities\" below) See also \"Text format\" above for information about the changes to the format parameter of long text fields. Log status \u00b6 In farmOS 1.x, logs had a boolean property called done which was either 1 (done) or 0 (not done). In 2.x, the done property has changed to status , and can be set to either done or pending . Additional states may be added in the future. Assets \u00b6 Asset records in farmOS 1.x had an entity type of farm_asset . In farmOS 2.x, the farm_ prefix has been dropped. The entity type is now simply asset . Asset types \u00b6 Asset type names are largely unchanged, with one notable exception: the \"Planting\" asset type has been renamed to \"Plant\". Below is the full list of asset types in farmOS 1.x and their new names in 2.x: animal (unchanged) compost (unchanged) equipment (unchanged) group (unchanged) planting -> plant sensor (unchanged) Asset fields \u00b6 Asset field names are largely unchanged, with a few exceptions (note that new fields are not listed here): animal_castrated -> is_castrated animal_nicknames -> nickname animal_sex -> sex animal_tag -> id_tag archived -> status and archived (see \"Asset status\" below) crop -> plant_type date -> birthdate (on animal assets) description -> notes (see also \"Text format\" above) flags -> flag files -> file images -> image Asset status \u00b6 In farmOS 1.x, assets had a property called archived which was either 0 , which indicated that the asset was active, or a timestamp that recorded when the asset was archived. In farmOS 2.x, these have been split into two separate fields: status - The status of the asset (either active or archived ). archived - The timestamp when the asset was archived. This will be empty if the asset is active. Taxonomies \u00b6 farmOS 2.x continues to use Drupal's core taxonomy_term entities to represent vocabularies of terms. The vocabulary machine names have changed, to drop the farm_ prefix, and to standardize plurality. farm_animal_types -> animal_type farm_areas has been removed (see \"Areas\" below) farm_log_categories -> log_category farm_materials -> material farm_season -> season farm_crops -> plant_type farm_crop_families -> crop_family farm_quantity_units -> unit Areas \u00b6 farmOS 2.x had the concept of \"Areas\" for representing places/locations. These were taxonomy terms in the farm_areas vocabulary. In farmOS 2.x, these areas are migrated to new asset types, and any asset can now be designated as a \"location\". New asset types are provided, including \"Land\", \"Structure\", and \"Water\", which have the \"location\" designation by default. Additional types can be provided by modules. Because any asset can be a location, some new fields are available on assets, including: is_location - Boolean indicating whether or not other assets can be moved to this asset. is_fixed - Boolean indicating that the asset has a fixed geometry and therefore does not move. intrinsic_geometry - A geofield representing the intrinsic geometry of \"fixed\" assets. Additionally, two \"computed\" fields are available on all assets, which provide quick access to the asset's current location and geometry, regardless of whether or not it is \"fixed\": geometry - The asset's current geometry. This will be the same as the intrinsic_geometry for \"fixed\" assets. Otherwise, it will mirror the geometry of the asset's most recent movement log. location - The asset's current location (an asset reference). This will always be empty for \"fixed\" assets. Otherwise, it will mirror the location reference field of the asset's most recent movement log. Quantities \u00b6 In farmOS 1.x, log quantities were saved within separate Field Collection entities. farmOS used the RESTful Web Services Field Collection module to hide the fact that these were separate entities, allowing their field to be accessed and modified in the same request to the host entity. In farmOS 2.x, quantities are represented as quantity entities. These are referenced under a log's relationships in JSON:API, and have a JSON:API resource name of quantity--quantity . In order to add a quantity to a new or existing log, they must be created in a separate API request before they can be referenced by the log. Quantities still have measure , value , unit and label fields.","title":"Changes"},{"location":"development/api/changes/#api-changes","text":"","title":"API Changes"},{"location":"development/api/changes/#2x-vs-1x","text":"farmOS 1.x used the RESTful Web Services module, which provided API endpoints for each entity type (asset, log, taxonomy term, etc). farmOS 2.x uses the new JSON:API module included with Drupal core, which follows the JSON:API specification for defining API resources. The root API endpoint is /api .","title":"2.x vs 1.x"},{"location":"development/api/changes/#json-schema","text":"farmOS 2.x also provides JSON Schema information about all available resources. The root endpoint for schema information is /api/schema . In farmOS 1.x, the /farm.json endpoint provided similar information in the resources property. This has been removed in favor of JSON Schema.","title":"JSON Schema"},{"location":"development/api/changes/#authentication","text":"See API Authentication for more information about authorizing and authenticating farmOS 2.x API requests. Notable changes from 1.x include: The new authorization URL is /oauth/authorize (was /oauth2/authorize ). The new token URL is /oauth/token (was /oauth2/token ). Requests should use Content-Type: application/vnd.api+json (was Content-Type: application/json ).","title":"Authentication"},{"location":"development/api/changes/#farm-info-endpoint","text":"In farmOS 1.x, an informational API endpoint was provided at /farm.json . This included various information describing the farmOS server configuration, authenticated user, installed languages and available entity types and bundles. This information was provided as either a simple value or a JSON object: { \"name\": \"My Farm\", \"url\": \"https://myfarm.mydomain.com\", \"api_version\": \"1.0\", \"system_of_measurement\": \"metric\", \"user\": { ... }, \"languages\": { ... }, \"resources\": { ... }, \"metrics\": { ... } } In farmOS 2.x, a root /api endpoint either provides this information, or is a gateway to this information. The simple values previously available from /farm.json are now provided in the meta.farm object at /api : { \"jsonapi\":{ ... }, \"data\":[], \"meta\":{ \"links\":{ \"me\":{ \"meta\":{ \"id\":\"7b2af019-3191-40ca-b221-616f9a365722\" }, \"href\":\"http://localhost/api/user/user/7b2af019-3191-40ca-b221-616f9a365722\" } }, \"farm\":{ \"name\":\"My farm name\", \"url\":\"http://localhost\", \"version\":\"2.x\", \"system_of_measurement\": \"metric\" } }, \"links\":{ ... } } The resources object has been replaced with the links object that describes all the available resource types and their endpoints. Information previously provided in the other JSON objects are now available as standalone resources at their respective endpoints: user - /api/user/user The authenticated user's ID is included in the meta.links.me object with a link to the user's resource. The user's attributes, such as name and language, can be retrieved from that endpoint. languages - /api/configurable_language/configurable_language","title":"Farm info endpoint"},{"location":"development/api/changes/#resource-endpoints","text":"In farmOS 1.x, API endpoints for each entity type were available at /[entity_type].json . For example: /log.json In farmOS 2.x, a root /api endpoint is provided, with a links object that describes all the available resource types and their endpoints. These follow a URL pattern of /api/[entity-type]/[bundle] . For example: /api/log/activity \"Bundles\" are \"sub-types\" that can have different sets (bundles) of fields on them. For example, a \"Seeding Log\" and a \"Harvest Log\" will collect different information, but both are \"Logs\" (events). To illustrate the difference between 1.x and 2.x, here are the endpoints for retrieving all Activity logs. farmOS 1.x: /log.json?type=farm_activity farmOS 2.x: /api/log/activity","title":"Resource endpoints"},{"location":"development/api/changes/#ids","text":"farmOS 2.x assigns UUIDs (universally unique identifiers) to all resources, and uses them in the API. This differs from farmOS 1.x, which used the integer IDs directly from the auto-incrementing database table that the record was pulled from. The benefit of UUIDs is they are guaranteed to be unique across multiple farmOS databases, whereas the old IDs were not. The internal integer IDs are not exposed via the API, so all code that needs to integrate should use the new UUIDs instead. Also note that the migration from farmOS 1.x to 2.x does not preserve the internal integer IDs, so they may be different after migrating to 2.x.","title":"IDs"},{"location":"development/api/changes/#record-structure","text":"JSON:API has some rules about how records are structured that differ from farmOS 1.x. These rules make the API more explicit. In farmOS 1.x, all the fields/properties of a record were on the same level. For example, a simple observation log looked like this: { \"id\": \"5\" \"type\": \"farm_observation\", \"name\": \"Test observation\", \"timestamp\": \"1526584271\", \"asset\": [ { \"resource\": \"farm_asset\", \"id\": \"123\" } ] } In farmOS 2.x, JSON:API dictates that the \"attributes\" and \"relationships\" of a record be explicitly declared under attributes and relationships properties in the JSON. The same record in farmOS 2.x looks like: { \"id\": \"9bc49ffd-76e8-4f86-b811-b721cb771327\" \"type\": \"log--observation\", \"attributes\": { \"name\": \"Test observation\", \"timestamp\": \"1526584271\", }, \"relationships\": { \"asset\": { \"data\": [ { \"type\": \"asset--animal\", \"id\": \"75116e3e-c45e-431d-8b58-1fce6bb315cf\", } ] } } }","title":"Record structure"},{"location":"development/api/changes/#filtering","text":"The URL query parameters for filtering results have a different syntax in 2.x. Refer to the Drupal.org JSON:API Filtering documentation for more information. To illustrate, this is how to filter activity logs by their completed status: farmOS 1.x: /log.json?type=activity&done=1 farmOS 2.x: /api/log/activity?filter[status]=complete","title":"Filtering"},{"location":"development/api/changes/#text-format","text":"Long text fields (like notes ) include value and format sub-properties, where value is the text value, and format is the \"Text format\" to use when displaying the text. This is used to filter user-supplied text, to only allow certain HTML tags (filtering out potential XSS vulnerabilities), convert URLs to links, etc. This works the same in farmOS 2.x, but the default format has changed from farm_format to default .","title":"Text format"},{"location":"development/api/changes/#logs","text":"","title":"Logs"},{"location":"development/api/changes/#log-types","text":"The farm_ prefix has been dropped from all log type names. For example, in farmOS 1.x an Activity log was farm_activity , and in farmOS 2.x it is simply activity . Additionally, the \"Soil test\" and \"Water test\" log types have been merged into a single \"Lab test\" log type. Below is the full list of log types in farmOS 1.x and their new names in 2.x: farm_activity -> activity farm_harvest -> harvest farm_input -> input farm_maintenance -> maintenance farm_medical -> medical farm_observation -> observation farm_purchase -> purchase farm_sale -> sale farm_seeding -> seeding farm_soil_test -> lab_test farm_transplanting -> transplanting farm_water_test -> lab_test","title":"Log types"},{"location":"development/api/changes/#log-fields","text":"Log field names are largely unchanged, with a few exceptions (note that new fields are not listed here): area -> location (See \"Areas\" below) date_purchase -> purchase_date done -> status (see \"Log status\" below) files -> file flags -> flag geofield -> geometry images -> image input_method -> method input_source -> source inventory (merged into quantity entities) log_category -> category log_owner -> owner seed_source -> source soil_lab -> lab water_lab -> lab quantity (see \"Quantities\" below) See also \"Text format\" above for information about the changes to the format parameter of long text fields.","title":"Log fields"},{"location":"development/api/changes/#log-status","text":"In farmOS 1.x, logs had a boolean property called done which was either 1 (done) or 0 (not done). In 2.x, the done property has changed to status , and can be set to either done or pending . Additional states may be added in the future.","title":"Log status"},{"location":"development/api/changes/#assets","text":"Asset records in farmOS 1.x had an entity type of farm_asset . In farmOS 2.x, the farm_ prefix has been dropped. The entity type is now simply asset .","title":"Assets"},{"location":"development/api/changes/#asset-types","text":"Asset type names are largely unchanged, with one notable exception: the \"Planting\" asset type has been renamed to \"Plant\". Below is the full list of asset types in farmOS 1.x and their new names in 2.x: animal (unchanged) compost (unchanged) equipment (unchanged) group (unchanged) planting -> plant sensor (unchanged)","title":"Asset types"},{"location":"development/api/changes/#asset-fields","text":"Asset field names are largely unchanged, with a few exceptions (note that new fields are not listed here): animal_castrated -> is_castrated animal_nicknames -> nickname animal_sex -> sex animal_tag -> id_tag archived -> status and archived (see \"Asset status\" below) crop -> plant_type date -> birthdate (on animal assets) description -> notes (see also \"Text format\" above) flags -> flag files -> file images -> image","title":"Asset fields"},{"location":"development/api/changes/#asset-status","text":"In farmOS 1.x, assets had a property called archived which was either 0 , which indicated that the asset was active, or a timestamp that recorded when the asset was archived. In farmOS 2.x, these have been split into two separate fields: status - The status of the asset (either active or archived ). archived - The timestamp when the asset was archived. This will be empty if the asset is active.","title":"Asset status"},{"location":"development/api/changes/#taxonomies","text":"farmOS 2.x continues to use Drupal's core taxonomy_term entities to represent vocabularies of terms. The vocabulary machine names have changed, to drop the farm_ prefix, and to standardize plurality. farm_animal_types -> animal_type farm_areas has been removed (see \"Areas\" below) farm_log_categories -> log_category farm_materials -> material farm_season -> season farm_crops -> plant_type farm_crop_families -> crop_family farm_quantity_units -> unit","title":"Taxonomies"},{"location":"development/api/changes/#areas","text":"farmOS 2.x had the concept of \"Areas\" for representing places/locations. These were taxonomy terms in the farm_areas vocabulary. In farmOS 2.x, these areas are migrated to new asset types, and any asset can now be designated as a \"location\". New asset types are provided, including \"Land\", \"Structure\", and \"Water\", which have the \"location\" designation by default. Additional types can be provided by modules. Because any asset can be a location, some new fields are available on assets, including: is_location - Boolean indicating whether or not other assets can be moved to this asset. is_fixed - Boolean indicating that the asset has a fixed geometry and therefore does not move. intrinsic_geometry - A geofield representing the intrinsic geometry of \"fixed\" assets. Additionally, two \"computed\" fields are available on all assets, which provide quick access to the asset's current location and geometry, regardless of whether or not it is \"fixed\": geometry - The asset's current geometry. This will be the same as the intrinsic_geometry for \"fixed\" assets. Otherwise, it will mirror the geometry of the asset's most recent movement log. location - The asset's current location (an asset reference). This will always be empty for \"fixed\" assets. Otherwise, it will mirror the location reference field of the asset's most recent movement log.","title":"Areas"},{"location":"development/api/changes/#quantities","text":"In farmOS 1.x, log quantities were saved within separate Field Collection entities. farmOS used the RESTful Web Services Field Collection module to hide the fact that these were separate entities, allowing their field to be accessed and modified in the same request to the host entity. In farmOS 2.x, quantities are represented as quantity entities. These are referenced under a log's relationships in JSON:API, and have a JSON:API resource name of quantity--quantity . In order to add a quantity to a new or existing log, they must be created in a separate API request before they can be referenced by the log. Quantities still have measure , value , unit and label fields.","title":"Quantities"},{"location":"development/environment/","text":"Getting started \u00b6 Follow these instructions to set up a local farmOS development environment. The only requirements are Docker and Docker Compose . 1. Set up Docker containers \u00b6 Run the following commands to create a farmOS directory and set up Docker containers for farmOS and PostgreSQL: mkdir farmOS && cd farmOS curl https://raw.githubusercontent.com/farmOS/farmOS/2.x/docker/docker-compose.development.yml -o docker-compose.yml docker-compose up -d 2. Install farmOS \u00b6 Open http://localhost in a browser and install farmOS with the following database credentials: Database type: PostgreSQL Database name: farm Database user: farm Database password: farm Advanced options > Host: db 3. Develop \u00b6 Open the www directory in your favorite IDE. Optional \u00b6 Configure private filesystem \u00b6 In order to upload files, a private file path must be configured. The following line must be added to www/web/sites/default/settings.php : $settings['file_private_path'] = '/opt/drupal/web/sites/default/private/files'; Configure debugger \u00b6 See Debugging . Enable HTTPS \u00b6 See HTTPS .","title":"Getting started"},{"location":"development/environment/#getting-started","text":"Follow these instructions to set up a local farmOS development environment. The only requirements are Docker and Docker Compose .","title":"Getting started"},{"location":"development/environment/#1-set-up-docker-containers","text":"Run the following commands to create a farmOS directory and set up Docker containers for farmOS and PostgreSQL: mkdir farmOS && cd farmOS curl https://raw.githubusercontent.com/farmOS/farmOS/2.x/docker/docker-compose.development.yml -o docker-compose.yml docker-compose up -d","title":"1. Set up Docker containers"},{"location":"development/environment/#2-install-farmos","text":"Open http://localhost in a browser and install farmOS with the following database credentials: Database type: PostgreSQL Database name: farm Database user: farm Database password: farm Advanced options > Host: db","title":"2. Install farmOS"},{"location":"development/environment/#3-develop","text":"Open the www directory in your favorite IDE.","title":"3. Develop"},{"location":"development/environment/#optional","text":"","title":"Optional"},{"location":"development/environment/#configure-private-filesystem","text":"In order to upload files, a private file path must be configured. The following line must be added to www/web/sites/default/settings.php : $settings['file_private_path'] = '/opt/drupal/web/sites/default/private/files';","title":"Configure private filesystem"},{"location":"development/environment/#configure-debugger","text":"See Debugging .","title":"Configure debugger"},{"location":"development/environment/#enable-https","text":"See HTTPS .","title":"Enable HTTPS"},{"location":"development/environment/code/","text":"Coding standards \u00b6 farmOS follows Drupal coding standards . The farmOS development Docker image comes pre-installed with PHP CodeSniffer for detecting code standard violations. The following command will run PHP CodeSniffer on all farmOS code: docker exec -it -u www-data farmos_www_1 phpcs /opt/drupal/web/profiles/farm If you see no output, then there are no issues. In some cases, code standard violations can be fixed automatically with phpcbf : docker exec -it -u www-data farmos_www_1 phpcbf /opt/drupal/web/profiles/farm","title":"Coding standards"},{"location":"development/environment/code/#coding-standards","text":"farmOS follows Drupal coding standards . The farmOS development Docker image comes pre-installed with PHP CodeSniffer for detecting code standard violations. The following command will run PHP CodeSniffer on all farmOS code: docker exec -it -u www-data farmos_www_1 phpcs /opt/drupal/web/profiles/farm If you see no output, then there are no issues. In some cases, code standard violations can be fixed automatically with phpcbf : docker exec -it -u www-data farmos_www_1 phpcbf /opt/drupal/web/profiles/farm","title":"Coding standards"},{"location":"development/environment/composer/","text":"Composer \u00b6 The farmOS development Docker image comes pre-installed with Composer , which is used for dependency management. Running Composer in Docker \u00b6 In order to run the composer command, you must use docker exec to run the command inside the farmOS container. docker exec -it -u www-data farmos_www_1 composer For example, the following will run the composer help command: docker exec -it -u www-data farmos_www_1 composer help' Warning : If composer update farmos/farmos is run, it will replace the Git repository in web/profiles/farm , discarding all changes/branches/remotes/etc. Common tasks \u00b6 Some common Composer tasks are documented here. Adding a module \u00b6 composer require drupal/[module] This will download the module into the web/modules/contrib directory, and add it to the root composer.json file. If the module is being added to the farmOS installation profile itself, you need to manually move the require line from the root composer.json to web/profiles/farm/composer.json and commit it to that repository. To install the module, use Drush . Notes \u00b6 Could not delete /var/www/html/web/sites/default/default.settings.php See https://www.drupal.org/docs/develop/using-composer/starting-a-site-using-drupal-composer-project-templates#s-troubleshooting-permission-issues-prevent-running-composer","title":"Composer"},{"location":"development/environment/composer/#composer","text":"The farmOS development Docker image comes pre-installed with Composer , which is used for dependency management.","title":"Composer"},{"location":"development/environment/composer/#running-composer-in-docker","text":"In order to run the composer command, you must use docker exec to run the command inside the farmOS container. docker exec -it -u www-data farmos_www_1 composer For example, the following will run the composer help command: docker exec -it -u www-data farmos_www_1 composer help' Warning : If composer update farmos/farmos is run, it will replace the Git repository in web/profiles/farm , discarding all changes/branches/remotes/etc.","title":"Running Composer in Docker"},{"location":"development/environment/composer/#common-tasks","text":"Some common Composer tasks are documented here.","title":"Common tasks"},{"location":"development/environment/composer/#adding-a-module","text":"composer require drupal/[module] This will download the module into the web/modules/contrib directory, and add it to the root composer.json file. If the module is being added to the farmOS installation profile itself, you need to manually move the require line from the root composer.json to web/profiles/farm/composer.json and commit it to that repository. To install the module, use Drush .","title":"Adding a module"},{"location":"development/environment/composer/#notes","text":"Could not delete /var/www/html/web/sites/default/default.settings.php See https://www.drupal.org/docs/develop/using-composer/starting-a-site-using-drupal-composer-project-templates#s-troubleshooting-permission-issues-prevent-running-composer","title":"Notes"},{"location":"development/environment/debug/","text":"Debugging \u00b6 The farmOS development Docker image comes pre-installed with XDebug 3, which allows debugger connections on port 9003. In order to connect to it, the XDEBUG_CONFIG environment variable must be used to configure XDebug's client_host setting with the Docker container's \"Gateway\" IP address. With the containers running, this command will print the gateway IP: docker inspect farmos_www_1 | grep -o '\"Gateway\": \".*\\..*\\..*\\..*\"' Edit docker-compose.yml and enter the gateway IP in the XDEBUG_CONFIG environment variable. For example: environment: XDEBUG_MODE: debug XDEBUG_CONFIG: client_host=192.168.128.1 Restart the Docker containers for this change to take affect. docker-compose restart Note : If the Docker containers are removed and recreated, the IP address may change, and you will need to repeat these steps to reconfigure it. PHPStorm \u00b6 If you are using the PHPStorm IDE, with the configuration above in place, enable the \"Start listening for PHP Debug Connections\" option. Add a breakpoint in your code, load the page in your browser, and you should see a prompt appear in PHPStorm that will begin the debugging session and pause execution at your breakpoint. Drush + PHPStorm \u00b6 Debugging code that is run via Drush commands requires additional configuration. Add an XDEBUG_SESSION environment variable with a value of PHPSTORM , and a PHP_IDE_CONFIG environment variable with a value of serverName=localhost , as follows: environment: XDEBUG_MODE: debug XDEBUG_CONFIG: client_host=192.168.128.1 XDEBUG_SESSION: PHPSTORM PHP_IDE_CONFIG: serverName=localhost Run a drush command and a prompt should appear in PHPStorm. You will need to map the path to Drush ( vendor/drush ) in the PHPStorm debugger config. Then you can set breakpoints in the Drush code you want to test.","title":"Debugging"},{"location":"development/environment/debug/#debugging","text":"The farmOS development Docker image comes pre-installed with XDebug 3, which allows debugger connections on port 9003. In order to connect to it, the XDEBUG_CONFIG environment variable must be used to configure XDebug's client_host setting with the Docker container's \"Gateway\" IP address. With the containers running, this command will print the gateway IP: docker inspect farmos_www_1 | grep -o '\"Gateway\": \".*\\..*\\..*\\..*\"' Edit docker-compose.yml and enter the gateway IP in the XDEBUG_CONFIG environment variable. For example: environment: XDEBUG_MODE: debug XDEBUG_CONFIG: client_host=192.168.128.1 Restart the Docker containers for this change to take affect. docker-compose restart Note : If the Docker containers are removed and recreated, the IP address may change, and you will need to repeat these steps to reconfigure it.","title":"Debugging"},{"location":"development/environment/debug/#phpstorm","text":"If you are using the PHPStorm IDE, with the configuration above in place, enable the \"Start listening for PHP Debug Connections\" option. Add a breakpoint in your code, load the page in your browser, and you should see a prompt appear in PHPStorm that will begin the debugging session and pause execution at your breakpoint.","title":"PHPStorm"},{"location":"development/environment/debug/#drush-phpstorm","text":"Debugging code that is run via Drush commands requires additional configuration. Add an XDEBUG_SESSION environment variable with a value of PHPSTORM , and a PHP_IDE_CONFIG environment variable with a value of serverName=localhost , as follows: environment: XDEBUG_MODE: debug XDEBUG_CONFIG: client_host=192.168.128.1 XDEBUG_SESSION: PHPSTORM PHP_IDE_CONFIG: serverName=localhost Run a drush command and a prompt should appear in PHPStorm. You will need to map the path to Drush ( vendor/drush ) in the PHPStorm debugger config. Then you can set breakpoints in the Drush code you want to test.","title":"Drush + PHPStorm"},{"location":"development/environment/docker/","text":"Docker \u00b6 Docker build arguments \u00b6 The farmOS Docker images allow certain variables to be overridden at image build time using the --build-arg parameter of docker build . Available arguments and their default values are described below: FARMOS_REPO - The farmOS Git repository URL. Default: https://github.com/farmOS/farmOS.git FARMOS_VERSION - The farmOS Git branch/tag/commit to check out. Default: 2.x PROJECT_REPO - The farmOS Composer project Git repository URL. Default: https://github.com/farmOS/composer-project.git PROJECT_VERSION - The farmOS Composer project Git branch/tag/commit to check out. Default: 2.x The 2.x-dev image also provides the following: WWW_DATA_ID - The ID to use for the www-data user and group inside the image. Setting this to the ID of the developer's user on the host machine allows Composer to create files owned by www-data inside the container, while keeping those files editable by the developer outside of the container. If your user ID is not 1000 , build the image with: --build-arg WWW_DATA_ID=$(id -u) Default: 1000","title":"Docker"},{"location":"development/environment/docker/#docker","text":"","title":"Docker"},{"location":"development/environment/docker/#docker-build-arguments","text":"The farmOS Docker images allow certain variables to be overridden at image build time using the --build-arg parameter of docker build . Available arguments and their default values are described below: FARMOS_REPO - The farmOS Git repository URL. Default: https://github.com/farmOS/farmOS.git FARMOS_VERSION - The farmOS Git branch/tag/commit to check out. Default: 2.x PROJECT_REPO - The farmOS Composer project Git repository URL. Default: https://github.com/farmOS/composer-project.git PROJECT_VERSION - The farmOS Composer project Git branch/tag/commit to check out. Default: 2.x The 2.x-dev image also provides the following: WWW_DATA_ID - The ID to use for the www-data user and group inside the image. Setting this to the ID of the developer's user on the host machine allows Composer to create files owned by www-data inside the container, while keeping those files editable by the developer outside of the container. If your user ID is not 1000 , build the image with: --build-arg WWW_DATA_ID=$(id -u) Default: 1000","title":"Docker build arguments"},{"location":"development/environment/documentation/","text":"Documentation \u00b6 In addition to the code for farmOS, this repository includes the source files of the documentation which is hosted at http://docs.farmos.org . It uses mkdocs to convert simple markdown files into static HTML files. To get started contributing to the farmOS 2.x documentation, fork farmOS on Github. Then install mkdocs and clone this repo: $ brew install python # For OSX users $ sudo apt-get install python-pip # For Debian/Ubuntu users $ sudo pip install mkdocs mkdocs-material $ git clone https://github.com/farmOS/farmOS.git farmOS $ cd farmOS $ git checkout 2.x $ git remote add sandbox git@github.com:<username>/farmOS.git $ mkdocs serve Your local farmOS 2.x documentation site should now be available for browsing: http://127.0.0.1:8000/. When you find a typo, an error, unclear or missing explanations or instructions, hit ctrl-c, to stop the server, and start editing. Find the page you\u2019d like to edit; everything is in the docs/ directory. Make your changes, commit and push them, and start a pull request: $ git checkout -b fix_typo # Create a new branch for your changes. ... # Make your changes. $ mkdocs build --clean; mkdocs serve # Go check your changes. $ git diff # Make sure there aren\u2019t any unintended changes. ... $ git commit -am \"Fixed typo.\" # Useful commit message are a good habit. $ git push sandbox fix_typo # Push your new branch up to your Github sandbox. Visit your fork on Github and start a Pull Request. For more information on writing and managing documentation with mkdocs, read the official mkdocs documentation: http://www.mkdocs.org","title":"Documentation"},{"location":"development/environment/documentation/#documentation","text":"In addition to the code for farmOS, this repository includes the source files of the documentation which is hosted at http://docs.farmos.org . It uses mkdocs to convert simple markdown files into static HTML files. To get started contributing to the farmOS 2.x documentation, fork farmOS on Github. Then install mkdocs and clone this repo: $ brew install python # For OSX users $ sudo apt-get install python-pip # For Debian/Ubuntu users $ sudo pip install mkdocs mkdocs-material $ git clone https://github.com/farmOS/farmOS.git farmOS $ cd farmOS $ git checkout 2.x $ git remote add sandbox git@github.com:<username>/farmOS.git $ mkdocs serve Your local farmOS 2.x documentation site should now be available for browsing: http://127.0.0.1:8000/. When you find a typo, an error, unclear or missing explanations or instructions, hit ctrl-c, to stop the server, and start editing. Find the page you\u2019d like to edit; everything is in the docs/ directory. Make your changes, commit and push them, and start a pull request: $ git checkout -b fix_typo # Create a new branch for your changes. ... # Make your changes. $ mkdocs build --clean; mkdocs serve # Go check your changes. $ git diff # Make sure there aren\u2019t any unintended changes. ... $ git commit -am \"Fixed typo.\" # Useful commit message are a good habit. $ git push sandbox fix_typo # Push your new branch up to your Github sandbox. Visit your fork on Github and start a Pull Request. For more information on writing and managing documentation with mkdocs, read the official mkdocs documentation: http://www.mkdocs.org","title":"Documentation"},{"location":"development/environment/drush/","text":"Drush \u00b6 The farmOS Docker image comes pre-installed with Drush , which provides shell commands for working with a Drupal installation. Running Drush in Docker \u00b6 In order to run the drush command, you must use docker exec to run the command inside the farmOS container. docker exec -it -u www-data farmos_www_1 drush For example, the following will run the drush cr command to rebuild caches: docker exec -it -u www-data farmos_www_1 drush cr Useful commands \u00b6 Some useful Drush commands are documented here. Rebuild caches \u00b6 drush cr Install a module \u00b6 drush en log","title":"Drush"},{"location":"development/environment/drush/#drush","text":"The farmOS Docker image comes pre-installed with Drush , which provides shell commands for working with a Drupal installation.","title":"Drush"},{"location":"development/environment/drush/#running-drush-in-docker","text":"In order to run the drush command, you must use docker exec to run the command inside the farmOS container. docker exec -it -u www-data farmos_www_1 drush For example, the following will run the drush cr command to rebuild caches: docker exec -it -u www-data farmos_www_1 drush cr","title":"Running Drush in Docker"},{"location":"development/environment/drush/#useful-commands","text":"Some useful Drush commands are documented here.","title":"Useful commands"},{"location":"development/environment/drush/#rebuild-caches","text":"drush cr","title":"Rebuild caches"},{"location":"development/environment/drush/#install-a-module","text":"drush en log","title":"Install a module"},{"location":"development/environment/https/","text":"Local HTTPS \u00b6 Some development testing is easier with farmOS on an https:// endpoint. A separate Nginx reverse proxy provides a simple way to achieve this without any changes to the Apache configuration that runs in the farmOS Docker container. First, generate self-signed SSL certificate files into an ssl directory, from the directory that your docker-compose.yml file is in: mkdir ssl openssl req -newkey rsa:4096 -x509 -sha256 -nodes -out ssl/openssl.crt -keyout ssl/openssl.key` Create a file called nginx.conf alongside docker-compose.yml : events {} http { server { listen 80 default_server; listen [::]:80 default_server; server_name _; return 301 https://$host$request_uri; } server { server_name localhost; listen 443 ssl; ssl_certificate /etc/nginx/ssl/openssl.crt; ssl_certificate_key /etc/nginx/ssl/openssl.key; location / { proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-Host $http_host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_pass http://www; } } } Add the following lines to www/web/sites/default/settings.php : $settings['reverse_proxy'] = TRUE; $settings['reverse_proxy_addresses'] = [!empty($_SERVER['REMOTE_ADDR']) ?? NULL]; $settings['reverse_proxy_trusted_headers'] = \\Symfony\\Component\\HttpFoundation\\Request::HEADER_X_FORWARDED_ALL; Add the following service to your local docker-compose.yml file: proxy: image: nginx depends_on: - www ports: - '80:80' - '443:443' volumes: - './nginx.conf:/etc/nginx/nginx.conf' - './ssl:/etc/nginx/ssl' Also remove port 80 from the www service: ports: - '80:80' Finally, start the Docker services: docker-compose up farmOS is now accessible via https://localhost .","title":"HTTPS"},{"location":"development/environment/https/#local-https","text":"Some development testing is easier with farmOS on an https:// endpoint. A separate Nginx reverse proxy provides a simple way to achieve this without any changes to the Apache configuration that runs in the farmOS Docker container. First, generate self-signed SSL certificate files into an ssl directory, from the directory that your docker-compose.yml file is in: mkdir ssl openssl req -newkey rsa:4096 -x509 -sha256 -nodes -out ssl/openssl.crt -keyout ssl/openssl.key` Create a file called nginx.conf alongside docker-compose.yml : events {} http { server { listen 80 default_server; listen [::]:80 default_server; server_name _; return 301 https://$host$request_uri; } server { server_name localhost; listen 443 ssl; ssl_certificate /etc/nginx/ssl/openssl.crt; ssl_certificate_key /etc/nginx/ssl/openssl.key; location / { proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-Host $http_host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_pass http://www; } } } Add the following lines to www/web/sites/default/settings.php : $settings['reverse_proxy'] = TRUE; $settings['reverse_proxy_addresses'] = [!empty($_SERVER['REMOTE_ADDR']) ?? NULL]; $settings['reverse_proxy_trusted_headers'] = \\Symfony\\Component\\HttpFoundation\\Request::HEADER_X_FORWARDED_ALL; Add the following service to your local docker-compose.yml file: proxy: image: nginx depends_on: - www ports: - '80:80' - '443:443' volumes: - './nginx.conf:/etc/nginx/nginx.conf' - './ssl:/etc/nginx/ssl' Also remove port 80 from the www service: ports: - '80:80' Finally, start the Docker services: docker-compose up farmOS is now accessible via https://localhost .","title":"Local HTTPS"},{"location":"development/environment/postgresql/","text":"PostgreSQL \u00b6 The farmOS Docker image comes pre-installed with the PostgreSQL client psql command, which can be used to connect to the database and run queries from the command line. Open PostgreSQL prompt \u00b6 docker exec -it farmos_www_1 psql -h db -d farm -U farm Enter farm as the password.","title":"PostgreSQL"},{"location":"development/environment/postgresql/#postgresql","text":"The farmOS Docker image comes pre-installed with the PostgreSQL client psql command, which can be used to connect to the database and run queries from the command line.","title":"PostgreSQL"},{"location":"development/environment/postgresql/#open-postgresql-prompt","text":"docker exec -it farmos_www_1 psql -h db -d farm -U farm Enter farm as the password.","title":"Open PostgreSQL prompt"},{"location":"development/environment/tests/","text":"Automated tests \u00b6 The farmOS development Docker image comes pre-installed with all the dependencies necessary for running automated tests via PHPUnit . The following command will run all automated tests provided by farmOS: docker exec -it -u www-data farmos_www_1 phpunit --verbose --debug /opt/drupal/web/profiles/farm Tests from other projects/dependencies can be run in a similar fashion. For example, the following command will run all tests in the Log module: docker exec -it -u www-data farmos_www_1 phpunit --verbose --debug /opt/drupal/web/modules/log Faster testing without XDebug \u00b6 The instructions above will run tests with XDebug enabled which may be helpful for debugging , but is also slower. One way to avoid XDebug is to run the tests via the prod farmOS image. The automated tests which run upon Github check-in follow this strategy which is orchestrated via run-tests.yml and a docker-compose file like docker-compose.testing.pgsql.yml - corresponding files also exist for MariaDB and SQLite . Something similar can be accomplished locally by adding an additional container to one's dev environment using the farmos/farmos:2.x image and mounting the same volume from the dev container to /opt/drupal . In a docker-compose.yml based off docker-compose.development.yml , this might look like; test-runner: image: farmos/farmos:2.x volumes: - './www:/opt/drupal' The tests could then be run via docker-compose exec as follows; docker-compose exec -u www-data -T test-runner phpunit --verbose --debug /opt/drupal/web/profiles/farm Note: As described in the farmOS docker documentation , the dev docker container uses a different user id for the www-data user - by default 1000. Since that id differs from the default www-data user id for the prod image - 33 - the permissions of the files mounted to /opt/drupal will cause tests to fail. Solutions to this will be specific to a developers environment, but some approaches are outlined below; Build a docker image derived from farmos/farmos:2.x which sets the id of the www-data user to match that of the dev image by including RUN usermod -u ${WWW_DATA_ID} www-data && groupmod -g ${WWW_DATA_ID} www-data and passing WWW_DATA_ID as a build build-arg Before launching the tests, use chmod / chown / setfacl to modify the permissions of the files mounted to /opt/drupal such that user id 33 can access them Rebuild the dev docker image to also use 33 as the user id of the www-data user","title":"Automated tests"},{"location":"development/environment/tests/#automated-tests","text":"The farmOS development Docker image comes pre-installed with all the dependencies necessary for running automated tests via PHPUnit . The following command will run all automated tests provided by farmOS: docker exec -it -u www-data farmos_www_1 phpunit --verbose --debug /opt/drupal/web/profiles/farm Tests from other projects/dependencies can be run in a similar fashion. For example, the following command will run all tests in the Log module: docker exec -it -u www-data farmos_www_1 phpunit --verbose --debug /opt/drupal/web/modules/log","title":"Automated tests"},{"location":"development/environment/tests/#faster-testing-without-xdebug","text":"The instructions above will run tests with XDebug enabled which may be helpful for debugging , but is also slower. One way to avoid XDebug is to run the tests via the prod farmOS image. The automated tests which run upon Github check-in follow this strategy which is orchestrated via run-tests.yml and a docker-compose file like docker-compose.testing.pgsql.yml - corresponding files also exist for MariaDB and SQLite . Something similar can be accomplished locally by adding an additional container to one's dev environment using the farmos/farmos:2.x image and mounting the same volume from the dev container to /opt/drupal . In a docker-compose.yml based off docker-compose.development.yml , this might look like; test-runner: image: farmos/farmos:2.x volumes: - './www:/opt/drupal' The tests could then be run via docker-compose exec as follows; docker-compose exec -u www-data -T test-runner phpunit --verbose --debug /opt/drupal/web/profiles/farm Note: As described in the farmOS docker documentation , the dev docker container uses a different user id for the www-data user - by default 1000. Since that id differs from the default www-data user id for the prod image - 33 - the permissions of the files mounted to /opt/drupal will cause tests to fail. Solutions to this will be specific to a developers environment, but some approaches are outlined below; Build a docker image derived from farmos/farmos:2.x which sets the id of the www-data user to match that of the dev image by including RUN usermod -u ${WWW_DATA_ID} www-data && groupmod -g ${WWW_DATA_ID} www-data and passing WWW_DATA_ID as a build build-arg Before launching the tests, use chmod / chown / setfacl to modify the permissions of the files mounted to /opt/drupal such that user id 33 can access them Rebuild the dev docker image to also use 33 as the user id of the www-data user","title":"Faster testing without XDebug"},{"location":"development/environment/update/","text":"Updating local environment \u00b6 The following commands will update your local farmOS development environment. This approach avoids running composer commands because that is already done when the Docker image is built. Warning : This will replace everything except the profiles and sites directories. If you are developing farmOS core, this will ensure that your farmOS Git repository (inside profiles/farm ) will not be touched. If you are developing a custom module, make sure that it is in sites/all/modules , otherwise it will be deleted. PHPStorm : If you are using PHPStorm, you will also want to make sure the .idea folder is not destroyed during this process. If it is in the www directory, be sure to move that out before running rm -r www below, and restore it afterwards. It is recommended that you close PHPStorm during this process to avoid any project settings corruption. # Run these commands from the local directory that contains docker-compose.yml. # The Docker containers should be running. # Backup www volume, just in case. sudo tar -czf www.tar.gz www # Pull latest 2.x-dev Docker image. docker pull farmos/farmos:2.x-dev # Move directories. mv www/web/profiles ./profiles mv www/web/sites ./sites # Update codebase. docker-compose down rm -r www docker-compose up -d # Restore directories. sudo rm -rf www/web/profiles www/web/sites mv ./profiles www/web/profiles mv ./sites www/web/sites # Update farmOS profile. cd www/web/profiles/farm git checkout 2.x && git pull origin 2.x # Run Drupal database updates. docker-compose exec -u www-data www drush updb","title":"Updating"},{"location":"development/environment/update/#updating-local-environment","text":"The following commands will update your local farmOS development environment. This approach avoids running composer commands because that is already done when the Docker image is built. Warning : This will replace everything except the profiles and sites directories. If you are developing farmOS core, this will ensure that your farmOS Git repository (inside profiles/farm ) will not be touched. If you are developing a custom module, make sure that it is in sites/all/modules , otherwise it will be deleted. PHPStorm : If you are using PHPStorm, you will also want to make sure the .idea folder is not destroyed during this process. If it is in the www directory, be sure to move that out before running rm -r www below, and restore it afterwards. It is recommended that you close PHPStorm during this process to avoid any project settings corruption. # Run these commands from the local directory that contains docker-compose.yml. # The Docker containers should be running. # Backup www volume, just in case. sudo tar -czf www.tar.gz www # Pull latest 2.x-dev Docker image. docker pull farmos/farmos:2.x-dev # Move directories. mv www/web/profiles ./profiles mv www/web/sites ./sites # Update codebase. docker-compose down rm -r www docker-compose up -d # Restore directories. sudo rm -rf www/web/profiles www/web/sites mv ./profiles www/web/profiles mv ./sites www/web/sites # Update farmOS profile. cd www/web/profiles/farm git checkout 2.x && git pull origin 2.x # Run Drupal database updates. docker-compose exec -u www-data www drush updb","title":"Updating local environment"},{"location":"development/module/","text":"farmOS module development \u00b6 farmOS modules can be written to extend the capabilities of farmOS. This document describes how to get started with farmOS module development. For detailed documentation of Drupal development more generally, refer to the guide on drupal.org . Modules directory \u00b6 Modules should be placed in the modules directory of the server's document root, at the same level as the profiles directory, which contains the farm profile (farmOS). If you are using the farmOS Docker image, this will be: /var/opt/drupal/web/modules farmOS automatically puts Drupal module dependencies in modules/contrib . A good practice is to download farmOS-specific modules into modules/farm to keep them separate. You may also consider creating a modules/custom directory for custom modules that are specific to your farmOS instance. Namespacing \u00b6 A farmOS (Drupal) module must have a unique name consisting only of lowercase alphanumeric characters and underscores. This is used as a namespace throughout the module, and allows Drupal hook functions to be executed on behalf of your module. It is best practice to prefix all farmOS-specific module names with farm_ . For example, if you were to build a module that adds a new log type called irrigation , you might name it farm_irrigation . This serves to specify that this module is made to work with farmOS, and is not designed to be installed in other Drupal sites more generally. File structure \u00b6 A farmOS (Drupal) module only requires one file for it to be recognized as a module: [modulename].info.yml (where [modulename] is the module name). This info YML file contains the module's human readable name, description, dependency declarations, and other meta information about the module. A very simple example looks like this: mylogtype.info.yml : name: My log type description: Adds my new custom log type. type: module package: farmOS Contrib core_version_requirement: ^9 dependencies: - farm:farm_entity Other common files and directories in a module include: [modulename].module - Optional PHP file for Drupal hook implementations. config/install/*.yml - Configuration entities that will be installed with the module. config/optional/*.yml - Optional configuration entities that will only be installed if certain dependencies are met. src/* - PHP classes organized using the PSR-4 autoloading specification. tests/* - Automated tests for the module. Publishing \u00b6 If you want to share your module, consider publishing the repository so that it can be downloaded and installed by other farmOS users. farmOS.org maintains a list of community modules, and accepts new additions via pull requests . It is recommended that \"contributed\" farmOS modules be made available as a \"project\" on Drupal.org . This has two benefits: Projects can be included via Composer with: composer require drupal/mymodule Translations can be automatically managed and downloaded from Drupal's centralized localization server: localize.drupal.org License \u00b6 farmOS modules that are distributed to others must be licensed under the GNU General Public License, version 2 or later . For more information about farmOS and Drupal module licensing requirements, refer to Drupal.org Licensing .","title":"Getting started"},{"location":"development/module/#farmos-module-development","text":"farmOS modules can be written to extend the capabilities of farmOS. This document describes how to get started with farmOS module development. For detailed documentation of Drupal development more generally, refer to the guide on drupal.org .","title":"farmOS module development"},{"location":"development/module/#modules-directory","text":"Modules should be placed in the modules directory of the server's document root, at the same level as the profiles directory, which contains the farm profile (farmOS). If you are using the farmOS Docker image, this will be: /var/opt/drupal/web/modules farmOS automatically puts Drupal module dependencies in modules/contrib . A good practice is to download farmOS-specific modules into modules/farm to keep them separate. You may also consider creating a modules/custom directory for custom modules that are specific to your farmOS instance.","title":"Modules directory"},{"location":"development/module/#namespacing","text":"A farmOS (Drupal) module must have a unique name consisting only of lowercase alphanumeric characters and underscores. This is used as a namespace throughout the module, and allows Drupal hook functions to be executed on behalf of your module. It is best practice to prefix all farmOS-specific module names with farm_ . For example, if you were to build a module that adds a new log type called irrigation , you might name it farm_irrigation . This serves to specify that this module is made to work with farmOS, and is not designed to be installed in other Drupal sites more generally.","title":"Namespacing"},{"location":"development/module/#file-structure","text":"A farmOS (Drupal) module only requires one file for it to be recognized as a module: [modulename].info.yml (where [modulename] is the module name). This info YML file contains the module's human readable name, description, dependency declarations, and other meta information about the module. A very simple example looks like this: mylogtype.info.yml : name: My log type description: Adds my new custom log type. type: module package: farmOS Contrib core_version_requirement: ^9 dependencies: - farm:farm_entity Other common files and directories in a module include: [modulename].module - Optional PHP file for Drupal hook implementations. config/install/*.yml - Configuration entities that will be installed with the module. config/optional/*.yml - Optional configuration entities that will only be installed if certain dependencies are met. src/* - PHP classes organized using the PSR-4 autoloading specification. tests/* - Automated tests for the module.","title":"File structure"},{"location":"development/module/#publishing","text":"If you want to share your module, consider publishing the repository so that it can be downloaded and installed by other farmOS users. farmOS.org maintains a list of community modules, and accepts new additions via pull requests . It is recommended that \"contributed\" farmOS modules be made available as a \"project\" on Drupal.org . This has two benefits: Projects can be included via Composer with: composer require drupal/mymodule Translations can be automatically managed and downloaded from Drupal's centralized localization server: localize.drupal.org","title":"Publishing"},{"location":"development/module/#license","text":"farmOS modules that are distributed to others must be licensed under the GNU General Public License, version 2 or later . For more information about farmOS and Drupal module licensing requirements, refer to Drupal.org Licensing .","title":"License"},{"location":"development/module/data_stream/","text":"Data Stream \u00b6 The data stream module provides a custom data stream entity for farmOS. Each data stream entity represents a time-series stream of data provided by a farmOS asset, such as Sensor or Equipment assets. Data streams can also specify any assets which their data is describing, such as a Plant, Animal or Land assets. Data streams are identified by a UUID , and have private_key and public fields to limit access to their data. Further functionality is provided by data stream types. Each type can provide a custom settings form, methods to retrieve and save data, methods for handling API requests, and custom display options. This allows custom data stream types to save data to the farmOS DB or request data from a third party API. Using data stream types \u00b6 The data stream bundle plugin class can be accessed from a data stream entity with the getPlugin() method: // Load the data stream. $data_streams = $this->entityTypeManager()->getStorage('data_stream')->loadByProperties([ 'uuid' => $uuid, ]); // Bail if UUID is not found. if (empty($data_streams)) { return; } /** @var \\Drupal\\data_stream\\Entity\\DataStreamInterface $data_stream */ $data_stream = reset($data_streams); // Get the data stream plugin. $plugin = $data_stream->getPlugin(); // Access methods on the plugin. // Available methods will vary depending on type. $data = $plugin->storageGet(); Core data stream types \u00b6 Basic data stream \u00b6 The data stream module provides a basic data stream type. Basic data streams receive data via the farmOS API and save data to the farmOS SQL database. Each basic data stream represents a single \"value\"; a sensor that records temperature and humidity would provide two data streams. Data can be accessed via the API with the private_key , or by anyone if the data stream is set to public . Basic data streams also provide simple ways to view data in a table or graph, and export as CSV. Listener (Legacy) data stream \u00b6 The farm_sensor_listener module provides a legacy_listener data stream type that is compatible with the Listener sensor type from farmOS 1.x. It is similar to the basic type but has a few differences: Each data stream saves multiple values (eg: temperature and humidity are saved to the same data stream) A public_key attribute identifies the data stream instead of a UUID . It responds to the legacy API endpoint at /farm/sensor/listener/{public_key} (to match farmOS 1.x). Custom data stream types \u00b6 Custom data stream types can be created to integrate with data stored outside of farmOS (such as time-series databases or 3rd party APIs), provide advanced views of data, and other custom behavior. Data stream types can be provided by adding two files to a module: An entity type config file (YAML), and: A bundle plugin class (PHP). For more information see Entity Types . Data stream bundle plugin \u00b6 Data stream bundle plugins must implement the DataStreamTypeInterface . The DataStreamTypeBase class can be used as starting point. Plugins can optionally implement the DataStreamStorageInterface and the DataStreamApiInterface to adhere to a common interface other data stream types might use. See the \"Basic\" data stream bundle plugin as an example ( Drupal\\data_stream\\Plugin\\DataStream\\DataStreamType\\Basic ).","title":"Data Stream"},{"location":"development/module/data_stream/#data-stream","text":"The data stream module provides a custom data stream entity for farmOS. Each data stream entity represents a time-series stream of data provided by a farmOS asset, such as Sensor or Equipment assets. Data streams can also specify any assets which their data is describing, such as a Plant, Animal or Land assets. Data streams are identified by a UUID , and have private_key and public fields to limit access to their data. Further functionality is provided by data stream types. Each type can provide a custom settings form, methods to retrieve and save data, methods for handling API requests, and custom display options. This allows custom data stream types to save data to the farmOS DB or request data from a third party API.","title":"Data Stream"},{"location":"development/module/data_stream/#using-data-stream-types","text":"The data stream bundle plugin class can be accessed from a data stream entity with the getPlugin() method: // Load the data stream. $data_streams = $this->entityTypeManager()->getStorage('data_stream')->loadByProperties([ 'uuid' => $uuid, ]); // Bail if UUID is not found. if (empty($data_streams)) { return; } /** @var \\Drupal\\data_stream\\Entity\\DataStreamInterface $data_stream */ $data_stream = reset($data_streams); // Get the data stream plugin. $plugin = $data_stream->getPlugin(); // Access methods on the plugin. // Available methods will vary depending on type. $data = $plugin->storageGet();","title":"Using data stream types"},{"location":"development/module/data_stream/#core-data-stream-types","text":"","title":"Core data stream types"},{"location":"development/module/data_stream/#basic-data-stream","text":"The data stream module provides a basic data stream type. Basic data streams receive data via the farmOS API and save data to the farmOS SQL database. Each basic data stream represents a single \"value\"; a sensor that records temperature and humidity would provide two data streams. Data can be accessed via the API with the private_key , or by anyone if the data stream is set to public . Basic data streams also provide simple ways to view data in a table or graph, and export as CSV.","title":"Basic data stream"},{"location":"development/module/data_stream/#listener-legacy-data-stream","text":"The farm_sensor_listener module provides a legacy_listener data stream type that is compatible with the Listener sensor type from farmOS 1.x. It is similar to the basic type but has a few differences: Each data stream saves multiple values (eg: temperature and humidity are saved to the same data stream) A public_key attribute identifies the data stream instead of a UUID . It responds to the legacy API endpoint at /farm/sensor/listener/{public_key} (to match farmOS 1.x).","title":"Listener (Legacy) data stream"},{"location":"development/module/data_stream/#custom-data-stream-types","text":"Custom data stream types can be created to integrate with data stored outside of farmOS (such as time-series databases or 3rd party APIs), provide advanced views of data, and other custom behavior. Data stream types can be provided by adding two files to a module: An entity type config file (YAML), and: A bundle plugin class (PHP). For more information see Entity Types .","title":"Custom data stream types"},{"location":"development/module/data_stream/#data-stream-bundle-plugin","text":"Data stream bundle plugins must implement the DataStreamTypeInterface . The DataStreamTypeBase class can be used as starting point. Plugins can optionally implement the DataStreamStorageInterface and the DataStreamApiInterface to adhere to a common interface other data stream types might use. See the \"Basic\" data stream bundle plugin as an example ( Drupal\\data_stream\\Plugin\\DataStream\\DataStreamType\\Basic ).","title":"Data stream bundle plugin"},{"location":"development/module/entities/","text":"Entity types \u00b6 Assets, logs, plans, taxonomy terms, users, etc are all types of \"entities\" in farmOS/Drupal terminology. Entities can have sub-types called \"bundles\", which represent \"bundles of fields\". Some fields may be common across all bundles of a given entity type, and some fields may be bundle-specific. Adding asset, log, and plan types \u00b6 Asset types, log types, and plan types can be provided by adding two files to a module: An entity type config file (YAML), and: A bundle plugin class (PHP). For example, the \"Activity\" log type is provided as follows: config/install/log.type.activity.yml : langcode: en status: true dependencies: enforced: module: - farm_activity id: activity label: Activity description: '' name_pattern: 'Activity log [log:id]' workflow: log_default new_revision: true src/Plugin/Log/LogType/Activity.php : <?php namespace Drupal\\farm_activity\\Plugin\\Log\\LogType; use Drupal\\farm_entity\\Plugin\\Log\\LogType\\FarmLogType; /** * Provides the activity log type. * * @LogType( * id = \"activity\", * label = @Translation(\"Activity\"), * ) */ class Activity extends FarmLogType { } Bundle fields \u00b6 Bundles can declare field definitions in their plugin class via the buildFieldDefinitions() method. A farm_field.factory helper service is provided to make this easier. The Equipment asset type does this to add \"Manufacturer\", \"Model\", and \"Serial number\" fields: /** * {@inheritdoc} */ public function buildFieldDefinitions() { $fields = parent::buildFieldDefinitions(); $field_info = [ 'manufacturer' => [ 'type' => 'string', 'label' => $this->t('Manufacturer'), 'weight' => [ 'form' => -20, 'view' => -50, ], ], 'model' => [ 'type' => 'string', 'label' => $this->t('Model'), 'weight' => [ 'form' => -15, 'view' => -40, ], ], 'serial_number' => [ 'type' => 'string', 'label' => $this->t('Serial number'), 'weight' => [ 'form' => -10, 'view' => -30, ], ], ]; foreach ($field_info as $name => $info) { $fields[$name] = \\Drupal::service('farm_field.factory')->bundleFieldDefinition($info); } return $fields; } For more information, see Adding fields .","title":"Entities"},{"location":"development/module/entities/#entity-types","text":"Assets, logs, plans, taxonomy terms, users, etc are all types of \"entities\" in farmOS/Drupal terminology. Entities can have sub-types called \"bundles\", which represent \"bundles of fields\". Some fields may be common across all bundles of a given entity type, and some fields may be bundle-specific.","title":"Entity types"},{"location":"development/module/entities/#adding-asset-log-and-plan-types","text":"Asset types, log types, and plan types can be provided by adding two files to a module: An entity type config file (YAML), and: A bundle plugin class (PHP). For example, the \"Activity\" log type is provided as follows: config/install/log.type.activity.yml : langcode: en status: true dependencies: enforced: module: - farm_activity id: activity label: Activity description: '' name_pattern: 'Activity log [log:id]' workflow: log_default new_revision: true src/Plugin/Log/LogType/Activity.php : <?php namespace Drupal\\farm_activity\\Plugin\\Log\\LogType; use Drupal\\farm_entity\\Plugin\\Log\\LogType\\FarmLogType; /** * Provides the activity log type. * * @LogType( * id = \"activity\", * label = @Translation(\"Activity\"), * ) */ class Activity extends FarmLogType { }","title":"Adding asset, log, and plan types"},{"location":"development/module/entities/#bundle-fields","text":"Bundles can declare field definitions in their plugin class via the buildFieldDefinitions() method. A farm_field.factory helper service is provided to make this easier. The Equipment asset type does this to add \"Manufacturer\", \"Model\", and \"Serial number\" fields: /** * {@inheritdoc} */ public function buildFieldDefinitions() { $fields = parent::buildFieldDefinitions(); $field_info = [ 'manufacturer' => [ 'type' => 'string', 'label' => $this->t('Manufacturer'), 'weight' => [ 'form' => -20, 'view' => -50, ], ], 'model' => [ 'type' => 'string', 'label' => $this->t('Model'), 'weight' => [ 'form' => -15, 'view' => -40, ], ], 'serial_number' => [ 'type' => 'string', 'label' => $this->t('Serial number'), 'weight' => [ 'form' => -10, 'view' => -30, ], ], ]; foreach ($field_info as $name => $info) { $fields[$name] = \\Drupal::service('farm_field.factory')->bundleFieldDefinition($info); } return $fields; } For more information, see Adding fields .","title":"Bundle fields"},{"location":"development/module/fields/","text":"Fields \u00b6 Adding fields \u00b6 A module may add additional fields to assets, logs, and other entity types in farmOS. The following documents how to add fields to existing entity types. See Entity types to understand how to create new asset, log, and plan types with custom fields on them. Base fields \u00b6 If the field should be added to all bundles of a given entity type (eg: all log types), then they should be added as \"base fields\" via hook_entity_base_field_info() . A farm_field.factory helper service is provided to make this easier: <?php use Drupal\\Core\\Entity\\EntityTypeInterface; /** * Implements hook_entity_base_field_info(). */ function mymodule_entity_base_field_info(EntityTypeInterface $entity_type) { $fields = []; // Add a new string field to Log entities. if ($entity_type->id() == 'log') { $options = [ 'type' => 'string', 'label' => t('My new field'), 'description' => t('My field description.'), 'weight' => [ 'form' => 10, 'view' => 10, ], ]; $fields['myfield'] = \\Drupal::service('farm_field.factory')->baseFieldDefinition($options); } return $fields; } Bundle fields \u00b6 If the field should only be added to a single bundle (eg: only \"Input\" logs), then they should be added as \"bundle fields\" via hook_farm_entity_bundle_field_info() * * Note that this is a custom hook provided by farmOS, which may be deprecated in favor of a core Drupal hook in the future. See core issue: https://www.drupal.org/node/2346347 The format for bundle field definitions is identical to base field definitions (above), but the bundleFieldDefinition() method must be used instead of baseFieldDefinition() . <?php use Drupal\\Core\\Entity\\EntityTypeInterface; /** * Implements hook_farm_entity_bundle_field_info(). */ function mymodule_farm_entity_bundle_field_info(EntityTypeInterface $entity_type, $bundle) { $fields = []; // Add a new string field to Input Logs. if ($entity_type->id() == 'log' && $bundle == 'input') { $options = [ 'type' => 'string', 'label' => t('My new field'), 'description' => t('My field description.'), 'weight' => [ 'form' => 10, 'view' => 10, ], ]; $fields['myfield'] = \\Drupal::service('farm_field.factory')->bundleFieldDefinition($options); } return $fields; } Select options \u00b6 Certain fields on assets and logs include a list of options to select from. These include: Flags (on assets and logs) Monitor ( monitor ) Needs review ( needs_review ) Priority ( priority ) Land types (on Land assets) Property ( property ) Field ( field ) Bed ( bed ) Paddock ( paddock ) Landmark ( landmark ) Other ( other ) Structure types (on Structure assets) Building ( building ) Greenhouse ( greenhouse ) Lab test type (on Lab test logs) Soil test ( soil ) Water test ( water ) ID tag type (on assets) Electronic ID ( eid , on all assets) Other ( other , on all assets) Brand ( brand , on Animal assets) Ear tag ( ear_tag , on Animal assets) Leg band ( leg_band , on Animal assets) Tattoo ( tattoo , on Animal assets) These options are provided as configuration entities by farmOS modules in the form of YAML files. Existing options can be overridden or removed by editing/deleting the entities in the active configuration of the site. ( Warning changing core types runs the risk of conflicting with future farmOS updates). Examples: \u00b6 Flag \u00b6 An \"Organic\" flag can be provided by a module named my_module by creating a file called farm_flag.flag.organic.yml in my_module/config/install : langcode: en status: true dependencies: enforced: module: - my_module id: monitor label: Monitor The most important parts are the id , which is a unique machine name for the flag, and label , which is the human readable/translatable label that will be shown in the select field and other parts of the UI. The langcode and status and dependencies are standard configuration entity properties. By putting the module's name in \"enforced modules\" it will ensure that the flag is removed when the module is uninstalled. Land type \u00b6 The \"Land\" module in farmOS provides a \"Field\" type like this: land/config/install/farm_land.land_type.field.yml langcode: en status: true dependencies: enforced: module: - farm_land id: field label: Field Structure type \u00b6 The \"Structure\" module in farmOS provides a \"Building\" type like this: structure/config/install/farm_structure.structure_type.building.yml langcode: en status: true dependencies: enforced: module: - farm_structure id: building label: Building Lab test type \u00b6 The \"Lab test\" module in farmOS provides a \"Soil test\" type like this: lab_test/config/install/farm_lab_test.lab_test_type.soil.yml langcode: en status: true dependencies: enforced: module: - farm_lab_test id: soil label: Soil test ID tag type \u00b6 ID tag types are similar to Flags, in that they have an id and label , but they also have an additional property: bundle . This allows the tag type to be limited to certain types of assets. For example, an \"Ear tag\" type, provided by the \"Animal asset\" module, only applies to \"Animal\" assets: animal/config/install/farm_flag.flag.ear_tag.yml langcode: en status: true dependencies: enforced: module: - farm_animal - farm_id_tag id: ear_tag label: Ear tag bundles: - animal If you want the tag type to apply to all assets, set bundles: null . (or can it just be omitted?)","title":"Fields"},{"location":"development/module/fields/#fields","text":"","title":"Fields"},{"location":"development/module/fields/#adding-fields","text":"A module may add additional fields to assets, logs, and other entity types in farmOS. The following documents how to add fields to existing entity types. See Entity types to understand how to create new asset, log, and plan types with custom fields on them.","title":"Adding fields"},{"location":"development/module/fields/#base-fields","text":"If the field should be added to all bundles of a given entity type (eg: all log types), then they should be added as \"base fields\" via hook_entity_base_field_info() . A farm_field.factory helper service is provided to make this easier: <?php use Drupal\\Core\\Entity\\EntityTypeInterface; /** * Implements hook_entity_base_field_info(). */ function mymodule_entity_base_field_info(EntityTypeInterface $entity_type) { $fields = []; // Add a new string field to Log entities. if ($entity_type->id() == 'log') { $options = [ 'type' => 'string', 'label' => t('My new field'), 'description' => t('My field description.'), 'weight' => [ 'form' => 10, 'view' => 10, ], ]; $fields['myfield'] = \\Drupal::service('farm_field.factory')->baseFieldDefinition($options); } return $fields; }","title":"Base fields"},{"location":"development/module/fields/#bundle-fields","text":"If the field should only be added to a single bundle (eg: only \"Input\" logs), then they should be added as \"bundle fields\" via hook_farm_entity_bundle_field_info() * * Note that this is a custom hook provided by farmOS, which may be deprecated in favor of a core Drupal hook in the future. See core issue: https://www.drupal.org/node/2346347 The format for bundle field definitions is identical to base field definitions (above), but the bundleFieldDefinition() method must be used instead of baseFieldDefinition() . <?php use Drupal\\Core\\Entity\\EntityTypeInterface; /** * Implements hook_farm_entity_bundle_field_info(). */ function mymodule_farm_entity_bundle_field_info(EntityTypeInterface $entity_type, $bundle) { $fields = []; // Add a new string field to Input Logs. if ($entity_type->id() == 'log' && $bundle == 'input') { $options = [ 'type' => 'string', 'label' => t('My new field'), 'description' => t('My field description.'), 'weight' => [ 'form' => 10, 'view' => 10, ], ]; $fields['myfield'] = \\Drupal::service('farm_field.factory')->bundleFieldDefinition($options); } return $fields; }","title":"Bundle fields"},{"location":"development/module/fields/#select-options","text":"Certain fields on assets and logs include a list of options to select from. These include: Flags (on assets and logs) Monitor ( monitor ) Needs review ( needs_review ) Priority ( priority ) Land types (on Land assets) Property ( property ) Field ( field ) Bed ( bed ) Paddock ( paddock ) Landmark ( landmark ) Other ( other ) Structure types (on Structure assets) Building ( building ) Greenhouse ( greenhouse ) Lab test type (on Lab test logs) Soil test ( soil ) Water test ( water ) ID tag type (on assets) Electronic ID ( eid , on all assets) Other ( other , on all assets) Brand ( brand , on Animal assets) Ear tag ( ear_tag , on Animal assets) Leg band ( leg_band , on Animal assets) Tattoo ( tattoo , on Animal assets) These options are provided as configuration entities by farmOS modules in the form of YAML files. Existing options can be overridden or removed by editing/deleting the entities in the active configuration of the site. ( Warning changing core types runs the risk of conflicting with future farmOS updates).","title":"Select options"},{"location":"development/module/fields/#examples","text":"","title":"Examples:"},{"location":"development/module/fields/#flag","text":"An \"Organic\" flag can be provided by a module named my_module by creating a file called farm_flag.flag.organic.yml in my_module/config/install : langcode: en status: true dependencies: enforced: module: - my_module id: monitor label: Monitor The most important parts are the id , which is a unique machine name for the flag, and label , which is the human readable/translatable label that will be shown in the select field and other parts of the UI. The langcode and status and dependencies are standard configuration entity properties. By putting the module's name in \"enforced modules\" it will ensure that the flag is removed when the module is uninstalled.","title":"Flag"},{"location":"development/module/fields/#land-type","text":"The \"Land\" module in farmOS provides a \"Field\" type like this: land/config/install/farm_land.land_type.field.yml langcode: en status: true dependencies: enforced: module: - farm_land id: field label: Field","title":"Land type"},{"location":"development/module/fields/#structure-type","text":"The \"Structure\" module in farmOS provides a \"Building\" type like this: structure/config/install/farm_structure.structure_type.building.yml langcode: en status: true dependencies: enforced: module: - farm_structure id: building label: Building","title":"Structure type"},{"location":"development/module/fields/#lab-test-type","text":"The \"Lab test\" module in farmOS provides a \"Soil test\" type like this: lab_test/config/install/farm_lab_test.lab_test_type.soil.yml langcode: en status: true dependencies: enforced: module: - farm_lab_test id: soil label: Soil test","title":"Lab test type"},{"location":"development/module/fields/#id-tag-type","text":"ID tag types are similar to Flags, in that they have an id and label , but they also have an additional property: bundle . This allows the tag type to be limited to certain types of assets. For example, an \"Ear tag\" type, provided by the \"Animal asset\" module, only applies to \"Animal\" assets: animal/config/install/farm_flag.flag.ear_tag.yml langcode: en status: true dependencies: enforced: module: - farm_animal - farm_id_tag id: ear_tag label: Ear tag bundles: - animal If you want the tag type to apply to all assets, set bundles: null . (or can it just be omitted?)","title":"ID tag type"},{"location":"development/module/oauth/","text":"OAuth \u00b6 The Simple OAuth module is used to provide an OAuth2 standard authorization server. For documentation on using and authenticating with the farmOS API see API . Providing OAuth Clients \u00b6 OAuth clients are modeled as \"Consumer\" entities (provided by the Consumers module. The farm_api module provides a default client with client_id = farm . This can be used for general usage of the API, but comes with limitations. To create a third party integration with farmOS a consumer entity must be created that identifies the integration and configures the OAuth Client authorization behavior. Scopes \u00b6 OAuth scopes define different levels of permission. OAuth clients are configured with the scopes needed for the purposes of a specific integration. With consumers, these scopes are implemented as Drupal Roles. This means that OAuth clients interacting with farmOS over the API use the same permission system as Users normally using the site. Client Configuration \u00b6 Standard Consumer configuration: consumer.label - A label used to identify the third party integration. consumer.client_id - An optional client_id machine name to identify the consumer. The simple_oauth module uses a UUID by default, but a machine name makes it easier to identify clients across multiple farmOS servers. consumer.secret - A client_secret used to secure the OAuth client. consumer.confidential - A boolean indicating whether the client secret needs to be validated. Most farmOS third party integrations will disable this. Otherwise the same client_secret must be configured on all farmOS servers, or the third party must keep track of a different secret for each server. This challenge is due to the nature of farmOS being a self-hosted application. consumer.user_id - When no specific user is authenticated Drupal will use this user as the author of all the actions made by this consumer. This is only the case during the Client Credentials authorization flow. consumer.redirect_uri - The URI this client will redirect to when needed. This is used with the Authorization Code authorization flow. consumer.third_party - Enable if the Consumer represents a third party. Users will skip the \"grant\" step of the authorization flow for first party consumers only. farmOS extends the consumers and simple_oauth modules to provide additional authorization options on consumer entities. These additional options make it possible to support different third party integration use cases via the same OAuth Authorization server. They can be configured via the UI or when creating a consumer entity programmatically. Authorization options (all are disabled by default): consumer.grant_user_access - Always grant the authorizing user's access to this consumer. This is how the farmOS Field Kit consumer is configured. If this is the only option enabled, then the consumer will only be granted the roles the user has access to. consumer.limit_requested_access - Only grant this consumer the scopes requested during authorization. By default, all scopes configured with the consumer will be granted during authorization. This allows users to select which scopes they want to grant the third party during authorization. consumer.limit_user_access - Never grant the consumer more access than the authorizing user. It is possible that clients will be configured with different roles than the user that authorizes access to a third party. There are times that this may be intentional, but this setting ensures that consumers will not be granted more access than the authorizing user.","title":"OAuth"},{"location":"development/module/oauth/#oauth","text":"The Simple OAuth module is used to provide an OAuth2 standard authorization server. For documentation on using and authenticating with the farmOS API see API .","title":"OAuth"},{"location":"development/module/oauth/#providing-oauth-clients","text":"OAuth clients are modeled as \"Consumer\" entities (provided by the Consumers module. The farm_api module provides a default client with client_id = farm . This can be used for general usage of the API, but comes with limitations. To create a third party integration with farmOS a consumer entity must be created that identifies the integration and configures the OAuth Client authorization behavior.","title":"Providing OAuth Clients"},{"location":"development/module/oauth/#scopes","text":"OAuth scopes define different levels of permission. OAuth clients are configured with the scopes needed for the purposes of a specific integration. With consumers, these scopes are implemented as Drupal Roles. This means that OAuth clients interacting with farmOS over the API use the same permission system as Users normally using the site.","title":"Scopes"},{"location":"development/module/oauth/#client-configuration","text":"Standard Consumer configuration: consumer.label - A label used to identify the third party integration. consumer.client_id - An optional client_id machine name to identify the consumer. The simple_oauth module uses a UUID by default, but a machine name makes it easier to identify clients across multiple farmOS servers. consumer.secret - A client_secret used to secure the OAuth client. consumer.confidential - A boolean indicating whether the client secret needs to be validated. Most farmOS third party integrations will disable this. Otherwise the same client_secret must be configured on all farmOS servers, or the third party must keep track of a different secret for each server. This challenge is due to the nature of farmOS being a self-hosted application. consumer.user_id - When no specific user is authenticated Drupal will use this user as the author of all the actions made by this consumer. This is only the case during the Client Credentials authorization flow. consumer.redirect_uri - The URI this client will redirect to when needed. This is used with the Authorization Code authorization flow. consumer.third_party - Enable if the Consumer represents a third party. Users will skip the \"grant\" step of the authorization flow for first party consumers only. farmOS extends the consumers and simple_oauth modules to provide additional authorization options on consumer entities. These additional options make it possible to support different third party integration use cases via the same OAuth Authorization server. They can be configured via the UI or when creating a consumer entity programmatically. Authorization options (all are disabled by default): consumer.grant_user_access - Always grant the authorizing user's access to this consumer. This is how the farmOS Field Kit consumer is configured. If this is the only option enabled, then the consumer will only be granted the roles the user has access to. consumer.limit_requested_access - Only grant this consumer the scopes requested during authorization. By default, all scopes configured with the consumer will be granted during authorization. This allows users to select which scopes they want to grant the third party during authorization. consumer.limit_user_access - Never grant the consumer more access than the authorizing user. It is possible that clients will be configured with different roles than the user that authorizes access to a third party. There are times that this may be intentional, but this setting ensures that consumers will not be granted more access than the authorizing user.","title":"Client Configuration"},{"location":"development/module/roles/","text":"Roles \u00b6 Roles are groups of permissions that can be assigned to users to grant them granular access to data and features in farmOS. Module developers can define new roles, and specify which permissions they should include. farmOS also builds on top of Drupal's role and permission system to provide a concept of \"Managed Roles\". Managed Roles \u00b6 The farmOS Access module provides methods to create user roles with permissions that are managed for the purposes of farmOS. These roles cannot be modified from the Admin Permissions UI. Instead, these roles allow permissions to be provided by other modules that want to provide sensible defaults for common farmOS roles. Creating a managed role \u00b6 User roles are provided as Drupal Configuration Entities. Managed roles are provided in the same way the only difference being that they include additional third party settings the farmOS Access module uses to build managed permissions. The user.role.*.third_party.farm_acccess schema defines the structure of these settings. access : An optional array of default access permissions. config : Boolean that specifies whether the role should have access to configuration. Only grant this to trusted roles. entity : Access permissions relating to entities. view all : Boolean that specifies the role should have access to view all bundles of all entity types. create all : Boolean that specifies the role should have access to create all bundles of all entity types. update all : Boolean that specifies the role should have access to update all bundles of all entity types. delete all : Boolean that specifies the role should have access to delete all bundles of all entity types. type : Access permissions for specific entity types. {entity_type} : The id of the entity type. eg: log , asset , taxonomy_term , etc. {operation} : The operation to grant bundles of this entity type. Eg: create , view any , view own , delete any , delete own , etc. {bundle} : The id of the entity type bundle or all to grant the operation permission to all bundles of the entity type. Settings used for the Manager role (full access to all entities + access to configuration): user.role.farm_manager.yml # (standard role config goes here) third_party_settings: farm_role: access: config: true entity: view all: true create all: true update all: true delete all: true Example settings to define a \"Harvester\" role with these limitations: View all log entities. Only create harvest logs, update harvest logs, and delete own harvest logs. View all asset entities. Only update planting assets. View, edit and delete any taxonomy_term entity. user.role.farm_harvester.yml # (standard role config goes here) third_party_settings: farm_role: access: entity: view all: true type: log: create: - harvest update any: - harvest delete own: - harvest asset: update any: - planting taxonomy_term: edit: - all delete: - all Providing permissions for managed roles \u00b6 Modules can define sensible permissions to any managed roles. These permissions are provided by creating a ManagedRolePermissions plugin in the module.managed_role_permissions.yml file. The following keys can be provided: default_permissions : A list of permissions that will be added to all managed roles. config_permissions : A list of permissions that will be added to managed roles that have access to configuration ( config: true ). permission_callbacks : A list of callbacks in controller notation that return an array of permissions to add to managed roles. Callbacks are provided a Role object so that permissions can be applied conditionally based on the managed role's settings. As an example, the farm_role module provides the following permissions: farm_role.managed_role_permissions.yml farm_role: default_permissions: - access content - access administration pages - access user profiles - access taxonomy overview config_permissions: - administer taxonomy Permission callbacks \u00b6 Example that adds permissions conditionally based on the role name and settings: Plugin definition: my_module.managed_role_permissions.yml my_module: permission_callbacks: - Drupal\\my_module\\CustomPermissions::permissions Example implementation of a permission_callback : my_module/src/CustomPermissions.php <?php namespace Drupal\\my_module; use Drupal\\user\\RoleInterface; /** * Example custom permission callback. */ class CustomPermissions { /** * Return an array of permission strings that will be added to the role. * * @param \\Drupal\\user\\RoleInterface $role * The role to add permissions to. * * @return array * An array of permission strings. */ public function permissions(RoleInterface $role) { // Array of permissions to return. $perms = []; // Add permissions based on role name. if ($role->id() == 'farm_manager') { $perms = 'my manager permission'; } // Get the farm_role third party settings from the Role entity. $access_settings = $role->getThirdPartySetting('farm_role', 'access'); $entity_settings = $access_settings['entity'] ?: []; // Only add permissions if `update all` and `delete all` are true. if (!empty($entity_settings['update all'] && $entity_settings['delete all'])) { $perms[] = 'recover all permission'; } // Return array of permissions. return $perms; } }","title":"Roles"},{"location":"development/module/roles/#roles","text":"Roles are groups of permissions that can be assigned to users to grant them granular access to data and features in farmOS. Module developers can define new roles, and specify which permissions they should include. farmOS also builds on top of Drupal's role and permission system to provide a concept of \"Managed Roles\".","title":"Roles"},{"location":"development/module/roles/#managed-roles","text":"The farmOS Access module provides methods to create user roles with permissions that are managed for the purposes of farmOS. These roles cannot be modified from the Admin Permissions UI. Instead, these roles allow permissions to be provided by other modules that want to provide sensible defaults for common farmOS roles.","title":"Managed Roles"},{"location":"development/module/roles/#creating-a-managed-role","text":"User roles are provided as Drupal Configuration Entities. Managed roles are provided in the same way the only difference being that they include additional third party settings the farmOS Access module uses to build managed permissions. The user.role.*.third_party.farm_acccess schema defines the structure of these settings. access : An optional array of default access permissions. config : Boolean that specifies whether the role should have access to configuration. Only grant this to trusted roles. entity : Access permissions relating to entities. view all : Boolean that specifies the role should have access to view all bundles of all entity types. create all : Boolean that specifies the role should have access to create all bundles of all entity types. update all : Boolean that specifies the role should have access to update all bundles of all entity types. delete all : Boolean that specifies the role should have access to delete all bundles of all entity types. type : Access permissions for specific entity types. {entity_type} : The id of the entity type. eg: log , asset , taxonomy_term , etc. {operation} : The operation to grant bundles of this entity type. Eg: create , view any , view own , delete any , delete own , etc. {bundle} : The id of the entity type bundle or all to grant the operation permission to all bundles of the entity type. Settings used for the Manager role (full access to all entities + access to configuration): user.role.farm_manager.yml # (standard role config goes here) third_party_settings: farm_role: access: config: true entity: view all: true create all: true update all: true delete all: true Example settings to define a \"Harvester\" role with these limitations: View all log entities. Only create harvest logs, update harvest logs, and delete own harvest logs. View all asset entities. Only update planting assets. View, edit and delete any taxonomy_term entity. user.role.farm_harvester.yml # (standard role config goes here) third_party_settings: farm_role: access: entity: view all: true type: log: create: - harvest update any: - harvest delete own: - harvest asset: update any: - planting taxonomy_term: edit: - all delete: - all","title":"Creating a managed role"},{"location":"development/module/roles/#providing-permissions-for-managed-roles","text":"Modules can define sensible permissions to any managed roles. These permissions are provided by creating a ManagedRolePermissions plugin in the module.managed_role_permissions.yml file. The following keys can be provided: default_permissions : A list of permissions that will be added to all managed roles. config_permissions : A list of permissions that will be added to managed roles that have access to configuration ( config: true ). permission_callbacks : A list of callbacks in controller notation that return an array of permissions to add to managed roles. Callbacks are provided a Role object so that permissions can be applied conditionally based on the managed role's settings. As an example, the farm_role module provides the following permissions: farm_role.managed_role_permissions.yml farm_role: default_permissions: - access content - access administration pages - access user profiles - access taxonomy overview config_permissions: - administer taxonomy","title":"Providing permissions for managed roles"},{"location":"development/module/roles/#permission-callbacks","text":"Example that adds permissions conditionally based on the role name and settings: Plugin definition: my_module.managed_role_permissions.yml my_module: permission_callbacks: - Drupal\\my_module\\CustomPermissions::permissions Example implementation of a permission_callback : my_module/src/CustomPermissions.php <?php namespace Drupal\\my_module; use Drupal\\user\\RoleInterface; /** * Example custom permission callback. */ class CustomPermissions { /** * Return an array of permission strings that will be added to the role. * * @param \\Drupal\\user\\RoleInterface $role * The role to add permissions to. * * @return array * An array of permission strings. */ public function permissions(RoleInterface $role) { // Array of permissions to return. $perms = []; // Add permissions based on role name. if ($role->id() == 'farm_manager') { $perms = 'my manager permission'; } // Get the farm_role third party settings from the Role entity. $access_settings = $role->getThirdPartySetting('farm_role', 'access'); $entity_settings = $access_settings['entity'] ?: []; // Only add permissions if `update all` and `delete all` are true. if (!empty($entity_settings['update all'] && $entity_settings['delete all'])) { $perms[] = 'recover all permission'; } // Return array of permissions. return $perms; } }","title":"Permission callbacks"},{"location":"development/module/services/","text":"Services \u00b6 farmOS provides some services that encapsulate common logic like querying logs and getting an asset's current location. Some of these services are documented here. Asset location service \u00b6 Service name : asset.location The asset location service provides methods that encapsulate the logic for determining an asset's location and geometry. Methods : isFixed($asset) - Check if an asset is fixed. Returns a boolean. hasLocation($asset) - Check if an asset is located within other location assets. Returns a boolean. hasGeometry($asset) - Check if an asset has geometry. Returns a boolean. getLocation($asset) - Get location assets that an asset is located within. Returns an array of asset entities. getGeometry($asset) - Get an asset's geometry. Returns a Well-Known Text string. getMovementLog($asset) - Find the latest movement log that references an asset. Returns a log entity, or NULL if no logs were found. setIntrinsicGeometry($asset, $wkt) - Set an asset's intrinsic geometry, given a string in Well-Known Text format. Example usage : // Get an asset's current geometry. $geometry = \\Drupal::service('asset.location')->getGeometry($asset); Asset inventory service \u00b6 Service name : asset.inventory The asset inventory service provides methods that encapsulate the logic for determining an asset's inventory. Methods : getInventory($asset, $measure = '', $units = '') - Get inventory summaries for an asset. Returns an array of arrays with the following keys: measure , value , units . This can be optionally filtered by $measure and $units . Example usage : // Get summaries of all inventories for an asset. $all_inventory = \\Drupal::service('asset.inventory')->getInventory($asset); // Get the current inventory for a given measure and units. $gallons_of_fertilizer = \\Drupal::service('asset.inventory')->getInventory($asset, 'volume', 'gallons'); Group membership service \u00b6 Service name : group.membership The group membership service provides methods that encapsulate the logic for determining an asset's group membership. This is provided by the optional Group Asset module, and will only be available if that module is installed. Methods : hasGroup() - Check if an asset is a member of a group. Returns a boolean. getGroup() - Get group assets that an asset is a member of. Returns an array of asset entities. getGroupAssignmentLog() - Find the latest group assignment log that references an asset. Returns a log entity, or NULL if no logs were found. Example usage: // Get the groups that an asset is a member of. $geometry = \\Drupal::service('group.membership')->getGroup($asset); Log query service \u00b6 Service name : log.query The log query service is a helper service for building a standard log database query. This is primarily used to query for the \"latest\" log of an asset. The asset location and group membership services use this. Methods : getQuery() - Builds a log database query. The query will be sorted by log timestamp and id , descending. It accepts a keyed array of options: type (string) - Filter by log type. timestamp (Unix timestamp) - Filter to logs by timestamp. Only logs with a timestamp less than or equal to this will be included. status (string) - Filter by log status. asset (asset entity) - Filter to logs that reference a particular asset. limit (int) - Only include this many results. Example usage : // Find the latest \"movement\" log for an asset. $options = [ 'asset' => $asset, 'timestamp' => \\Drupal::time()->getCurrentTime(), 'status' => 'done', 'limit' => 1, ]; $query = \\Drupal::service('log.query')->getQuery($options); $query->condition('is_movement', TRUE); $log_ids = $query->execute(); // Load the first log. $log = \\Drupal::service('entity_type.manager')->getStorage('log')->load(reset($log_ids));","title":"Services"},{"location":"development/module/services/#services","text":"farmOS provides some services that encapsulate common logic like querying logs and getting an asset's current location. Some of these services are documented here.","title":"Services"},{"location":"development/module/services/#asset-location-service","text":"Service name : asset.location The asset location service provides methods that encapsulate the logic for determining an asset's location and geometry. Methods : isFixed($asset) - Check if an asset is fixed. Returns a boolean. hasLocation($asset) - Check if an asset is located within other location assets. Returns a boolean. hasGeometry($asset) - Check if an asset has geometry. Returns a boolean. getLocation($asset) - Get location assets that an asset is located within. Returns an array of asset entities. getGeometry($asset) - Get an asset's geometry. Returns a Well-Known Text string. getMovementLog($asset) - Find the latest movement log that references an asset. Returns a log entity, or NULL if no logs were found. setIntrinsicGeometry($asset, $wkt) - Set an asset's intrinsic geometry, given a string in Well-Known Text format. Example usage : // Get an asset's current geometry. $geometry = \\Drupal::service('asset.location')->getGeometry($asset);","title":"Asset location service"},{"location":"development/module/services/#asset-inventory-service","text":"Service name : asset.inventory The asset inventory service provides methods that encapsulate the logic for determining an asset's inventory. Methods : getInventory($asset, $measure = '', $units = '') - Get inventory summaries for an asset. Returns an array of arrays with the following keys: measure , value , units . This can be optionally filtered by $measure and $units . Example usage : // Get summaries of all inventories for an asset. $all_inventory = \\Drupal::service('asset.inventory')->getInventory($asset); // Get the current inventory for a given measure and units. $gallons_of_fertilizer = \\Drupal::service('asset.inventory')->getInventory($asset, 'volume', 'gallons');","title":"Asset inventory service"},{"location":"development/module/services/#group-membership-service","text":"Service name : group.membership The group membership service provides methods that encapsulate the logic for determining an asset's group membership. This is provided by the optional Group Asset module, and will only be available if that module is installed. Methods : hasGroup() - Check if an asset is a member of a group. Returns a boolean. getGroup() - Get group assets that an asset is a member of. Returns an array of asset entities. getGroupAssignmentLog() - Find the latest group assignment log that references an asset. Returns a log entity, or NULL if no logs were found. Example usage: // Get the groups that an asset is a member of. $geometry = \\Drupal::service('group.membership')->getGroup($asset);","title":"Group membership service"},{"location":"development/module/services/#log-query-service","text":"Service name : log.query The log query service is a helper service for building a standard log database query. This is primarily used to query for the \"latest\" log of an asset. The asset location and group membership services use this. Methods : getQuery() - Builds a log database query. The query will be sorted by log timestamp and id , descending. It accepts a keyed array of options: type (string) - Filter by log type. timestamp (Unix timestamp) - Filter to logs by timestamp. Only logs with a timestamp less than or equal to this will be included. status (string) - Filter by log status. asset (asset entity) - Filter to logs that reference a particular asset. limit (int) - Only include this many results. Example usage : // Find the latest \"movement\" log for an asset. $options = [ 'asset' => $asset, 'timestamp' => \\Drupal::time()->getCurrentTime(), 'status' => 'done', 'limit' => 1, ]; $query = \\Drupal::service('log.query')->getQuery($options); $query->condition('is_movement', TRUE); $log_ids = $query->execute(); // Load the first log. $log = \\Drupal::service('entity_type.manager')->getStorage('log')->load(reset($log_ids));","title":"Log query service"},{"location":"development/module/updates/","text":"Automated updates \u00b6 farmOS modules may change and evolve over time. If these changes require updates to a farmOS database or configuration, then update logic should be provided so that users of the module can perform the necessary changes automatically when they update to the new version. This logic can be supplied via implementations of hook_update_N() . For more information, see the documentation for Drupal's Update API .","title":"Updates"},{"location":"development/module/updates/#automated-updates","text":"farmOS modules may change and evolve over time. If these changes require updates to a farmOS database or configuration, then update logic should be provided so that users of the module can perform the necessary changes automatically when they update to the new version. This logic can be supplied via implementations of hook_update_N() . For more information, see the documentation for Drupal's Update API .","title":"Automated updates"},{"location":"hosting/","text":"Hosting farmOS \u00b6 farmOS is a web-based application that can be installed and hosted on a web server, much like a website. This allows it to be accessed by multiple people simultaneously, from any device with a web browser and internet connection. Self hosting \u00b6 If you are familiar with hosting database-backed websites, you can install farmOS on your own web server. farmOS is free software , which means you are free to download the code and host it yourself. You are also free to modify and extend it to fit your needs. For more information, including server requirements, refer to Installing farmOS . To understand how to update farmOS when a new version is released, refer to Updating farmOS . Subscription hosting \u00b6 If you are not comfortable hosting and maintaining your own server, subscription hosting allows you to get started with farmOS quickly and easily. Farmier is a subscription hosting service that provides \" farmOS as a service \", including hosting, automatic updates, backups, SSL security, and other features. Farmier was started by the creator of farmOS, and subscriptions help to support the continued development of farmOS. For more information, visit https://farmier.com .","title":"Introduction"},{"location":"hosting/#hosting-farmos","text":"farmOS is a web-based application that can be installed and hosted on a web server, much like a website. This allows it to be accessed by multiple people simultaneously, from any device with a web browser and internet connection.","title":"Hosting farmOS"},{"location":"hosting/#self-hosting","text":"If you are familiar with hosting database-backed websites, you can install farmOS on your own web server. farmOS is free software , which means you are free to download the code and host it yourself. You are also free to modify and extend it to fit your needs. For more information, including server requirements, refer to Installing farmOS . To understand how to update farmOS when a new version is released, refer to Updating farmOS .","title":"Self hosting"},{"location":"hosting/#subscription-hosting","text":"If you are not comfortable hosting and maintaining your own server, subscription hosting allows you to get started with farmOS quickly and easily. Farmier is a subscription hosting service that provides \" farmOS as a service \", including hosting, automatic updates, backups, SSL security, and other features. Farmier was started by the creator of farmOS, and subscriptions help to support the continued development of farmOS. For more information, visit https://farmier.com .","title":"Subscription hosting"},{"location":"hosting/email/","text":"Email configuration \u00b6 farmOS needs to be able to send emails to users. This is used for password reset emails, notifications, etc. Depending on how you have farmOS deployed, there are a few ways to configure your server to allow farmOS to send emails. By default, farmOS will attempt to send emails via an SMTP server installed on the same system. If you have Postfix installed, email should work without any additional configuration, although they will most likely be filtered as spam. This StackOverflow topic provides guidance for avoiding this. Docker \u00b6 The farmOS Docker images do not include an SMTP server, so you will see this error message when farmOS tries to send an email: Unable to send e-mail. Contact the site administrator if the problem persists. There are two potential solutions to this: Install and configure the SMTP module. This is a contributed Drupal module that allows emails to be relayed through a third-party SMTP server. This module is not included with farmOS, but can be downloaded into [farmOS-codebase]/web/sites/all/modules and enabled in https://[farmOS-hostname]/admin/modules . Create your own Docker image which inherits from the farmOS image. This image can install an SMTP server like Postfix, which can be configured to send email directly, or relay it through another SMTP server.","title":"Email"},{"location":"hosting/email/#email-configuration","text":"farmOS needs to be able to send emails to users. This is used for password reset emails, notifications, etc. Depending on how you have farmOS deployed, there are a few ways to configure your server to allow farmOS to send emails. By default, farmOS will attempt to send emails via an SMTP server installed on the same system. If you have Postfix installed, email should work without any additional configuration, although they will most likely be filtered as spam. This StackOverflow topic provides guidance for avoiding this.","title":"Email configuration"},{"location":"hosting/email/#docker","text":"The farmOS Docker images do not include an SMTP server, so you will see this error message when farmOS tries to send an email: Unable to send e-mail. Contact the site administrator if the problem persists. There are two potential solutions to this: Install and configure the SMTP module. This is a contributed Drupal module that allows emails to be relayed through a third-party SMTP server. This module is not included with farmOS, but can be downloaded into [farmOS-codebase]/web/sites/all/modules and enabled in https://[farmOS-hostname]/admin/modules . Create your own Docker image which inherits from the farmOS image. This image can install an SMTP server like Postfix, which can be configured to send email directly, or relay it through another SMTP server.","title":"Docker"},{"location":"hosting/install/","text":"Installing farmOS \u00b6 Server requirements \u00b6 farmOS is based on Drupal , and therefore shares many of the same requirements . Web server \u00b6 In addition to Drupal's basic requirements, farmOS has the following server dependencies. The farmOS Docker images include these. PHP 7+ PHP configuration - The following PHP settings are recommended: memory_limit=256M max_execution_time=240 max_input_time=240 max_input_vars=5000 realpath_cache_size=4096K realpath_cache_ttl=3600 PHP BCMath extension is required for accurate geometric polygon area calculations. GEOS is required by the Bed Generator module. Database server \u00b6 A database server needs to be provisioned that farmOS can connect to. PostgreSQL is recommended. MySQL/MariaDB and SQLite are also supported. This can be installed on the same server as farmOS (either directly or in a Docker container), or it can be on a separate server. SSL \u00b6 Although not strictly a requirement, some features (like the \"Geolocate\" button on maps) will only work over a secure connection. Field Kit requires SSL in order to connect to it. SSL is also recommended if you are streaming sensor data into farmOS, to keep your sensor's private key a secret. A common strategy is to use Nginx as a reverse proxy with SSL termination, which listens on port 443 and forwards to farmOS on port 80. Let's Encrypt is a good option for free SSL certificate issuance, and renewal can be automated via cron. These resources may be helpful: Drupal HTTPS Information Reverse Proxy Forum Post - Includes links to related GitHub issues and examples of how others have configured reverse proxies serving HTTPS. Local HTTPS - Documentation for running an Nginx reverse proxy with self-signed certificates for local farmOS development with HTTPS. API Keys \u00b6 Optional modules are available for adding satellite imagery layers to maps (eg: Mapbox, Google Maps, etc). However, because these layers are hosted by third-party providers, API keys are required to use them. Instructions for obtaining API keys are available via the links below. API keys can be entered into farmOS by going to Settings > Map. Mapbox Google Maps farmOS Codebase \u00b6 There are two supported approaches to deploying the farmOS codebase: Using Docker images. Using packaged releases. Docker is the recommended method of hosting farmOS because it encapsulates the server level dependencies that farmOS needs. farmOS in Docker \u00b6 Official farmOS Docker images are available on Docker Hub: https://hub.docker.com/r/farmos/farmos This allows farmOS to be run in a Docker container with: docker pull farmos/farmos:2.x docker run --rm -p 80:80 -v \"${PWD}/sites:/opt/drupal/web/sites\" farmos/farmos:2.x This will pull the farmOS Docker image, provision a farmOS web server container listening on port 80, and bind-mount a sites directory into the container for persistence of settings and uploaded files. Docker Compose \u00b6 Docker Compose can be used to encapsulate these decisions. An example docker-compose.production.yml configuration file is provided in the farmOS repository's docker directory, with an accompanying README.md . Copy this to a file named docker-compose.yml in the directory you would like to install farmOS and run: docker-compose up -d Persistence \u00b6 All site-specific settings and user-uploaded files are stored in /opt/drupal/web/sites inside the container, so it is important that the contents of this directory be persisted outside of the container. Bind-mounting a directory from the host into the container is the recommended way to achieve this. The docker run command above does this, as well as the example docker-compose.yml provided in the farmOS repository's docker directory. If the sites directory is not persisted, all settings and files will be lost when the container is destroyed, and you will be prompted to install farmOS again when a new container is started. Customizing PHP \u00b6 If customizations to PHP's configuration are required, such as increasing the maximum upload size limit, you can bind-mount a custom PHP settings file into the container. Create a file called php.ini alongside docker-compose.yml : upload_max_filesize = 50M post_max_size = 50M Bind-mount php.ini into the www service in your docker-compose.yml file: volumes: ... - './php.ini:/usr/local/etc/php/conf.d/farmos.ini' Packaged releases \u00b6 An alternative to the Docker-based deployment is to install the farmOS codebase directly on the host server using a packaged release tarball, available from GitHub: github.com/farmOS/farmOS/releases Packaged releases include everything from the /opt/drupal directory in the Docker image. This represents the entire farmOS codebase, pre-built with Composer . Download and unpack the tarball on your web server, and point the document root at the web subdirectory. Installing farmOS \u00b6 Once you have the farmOS codebase deployed, and a database server provisioned, you can proceed with the web-based farmOS installation. Visit the farmOS server's hostname in your browser and follow the steps to install farmOS and optional modules.","title":"Installing"},{"location":"hosting/install/#installing-farmos","text":"","title":"Installing farmOS"},{"location":"hosting/install/#server-requirements","text":"farmOS is based on Drupal , and therefore shares many of the same requirements .","title":"Server requirements"},{"location":"hosting/install/#web-server","text":"In addition to Drupal's basic requirements, farmOS has the following server dependencies. The farmOS Docker images include these. PHP 7+ PHP configuration - The following PHP settings are recommended: memory_limit=256M max_execution_time=240 max_input_time=240 max_input_vars=5000 realpath_cache_size=4096K realpath_cache_ttl=3600 PHP BCMath extension is required for accurate geometric polygon area calculations. GEOS is required by the Bed Generator module.","title":"Web server"},{"location":"hosting/install/#database-server","text":"A database server needs to be provisioned that farmOS can connect to. PostgreSQL is recommended. MySQL/MariaDB and SQLite are also supported. This can be installed on the same server as farmOS (either directly or in a Docker container), or it can be on a separate server.","title":"Database server"},{"location":"hosting/install/#ssl","text":"Although not strictly a requirement, some features (like the \"Geolocate\" button on maps) will only work over a secure connection. Field Kit requires SSL in order to connect to it. SSL is also recommended if you are streaming sensor data into farmOS, to keep your sensor's private key a secret. A common strategy is to use Nginx as a reverse proxy with SSL termination, which listens on port 443 and forwards to farmOS on port 80. Let's Encrypt is a good option for free SSL certificate issuance, and renewal can be automated via cron. These resources may be helpful: Drupal HTTPS Information Reverse Proxy Forum Post - Includes links to related GitHub issues and examples of how others have configured reverse proxies serving HTTPS. Local HTTPS - Documentation for running an Nginx reverse proxy with self-signed certificates for local farmOS development with HTTPS.","title":"SSL"},{"location":"hosting/install/#api-keys","text":"Optional modules are available for adding satellite imagery layers to maps (eg: Mapbox, Google Maps, etc). However, because these layers are hosted by third-party providers, API keys are required to use them. Instructions for obtaining API keys are available via the links below. API keys can be entered into farmOS by going to Settings > Map. Mapbox Google Maps","title":"API Keys"},{"location":"hosting/install/#farmos-codebase","text":"There are two supported approaches to deploying the farmOS codebase: Using Docker images. Using packaged releases. Docker is the recommended method of hosting farmOS because it encapsulates the server level dependencies that farmOS needs.","title":"farmOS Codebase"},{"location":"hosting/install/#farmos-in-docker","text":"Official farmOS Docker images are available on Docker Hub: https://hub.docker.com/r/farmos/farmos This allows farmOS to be run in a Docker container with: docker pull farmos/farmos:2.x docker run --rm -p 80:80 -v \"${PWD}/sites:/opt/drupal/web/sites\" farmos/farmos:2.x This will pull the farmOS Docker image, provision a farmOS web server container listening on port 80, and bind-mount a sites directory into the container for persistence of settings and uploaded files.","title":"farmOS in Docker"},{"location":"hosting/install/#docker-compose","text":"Docker Compose can be used to encapsulate these decisions. An example docker-compose.production.yml configuration file is provided in the farmOS repository's docker directory, with an accompanying README.md . Copy this to a file named docker-compose.yml in the directory you would like to install farmOS and run: docker-compose up -d","title":"Docker Compose"},{"location":"hosting/install/#persistence","text":"All site-specific settings and user-uploaded files are stored in /opt/drupal/web/sites inside the container, so it is important that the contents of this directory be persisted outside of the container. Bind-mounting a directory from the host into the container is the recommended way to achieve this. The docker run command above does this, as well as the example docker-compose.yml provided in the farmOS repository's docker directory. If the sites directory is not persisted, all settings and files will be lost when the container is destroyed, and you will be prompted to install farmOS again when a new container is started.","title":"Persistence"},{"location":"hosting/install/#customizing-php","text":"If customizations to PHP's configuration are required, such as increasing the maximum upload size limit, you can bind-mount a custom PHP settings file into the container. Create a file called php.ini alongside docker-compose.yml : upload_max_filesize = 50M post_max_size = 50M Bind-mount php.ini into the www service in your docker-compose.yml file: volumes: ... - './php.ini:/usr/local/etc/php/conf.d/farmos.ini'","title":"Customizing PHP"},{"location":"hosting/install/#packaged-releases","text":"An alternative to the Docker-based deployment is to install the farmOS codebase directly on the host server using a packaged release tarball, available from GitHub: github.com/farmOS/farmOS/releases Packaged releases include everything from the /opt/drupal directory in the Docker image. This represents the entire farmOS codebase, pre-built with Composer . Download and unpack the tarball on your web server, and point the document root at the web subdirectory.","title":"Packaged releases"},{"location":"hosting/install/#installing-farmos_1","text":"Once you have the farmOS codebase deployed, and a database server provisioned, you can proceed with the web-based farmOS installation. Visit the farmOS server's hostname in your browser and follow the steps to install farmOS and optional modules.","title":"Installing farmOS"},{"location":"hosting/migration/","text":"Migrating from farmOS 1.x to 2.x \u00b6 The upgrade path from farmOS 1.x to 2.x is performed via a database migration. farmOS 2.x includes a farmOS Migrate module that leverage's Drupal core's Migrate API to provide migrations for each asset type, log type, etc. These migrations are defined in YML configuration files included with the farmOS Migrate module. Important considerations \u00b6 Do not migrate into a farmOS 2.x instance that already has records. This is to ensure that the internal auto-incrementing IDs of records are maintained. Execute the migrations in the exact order they are shown below. It is especially important that all assets are migrated before any areas, because areas are converted to assets during the migration, which can cause ID conflicts/collisions. See Issue #3203228 Uploaded photos/files must be copied to the destination filesystem before migrating. See Migrating files below. See Limitations below. Running the migration \u00b6 Follow the steps below to migrate your farmOS 1.x data to farmOS 2.x: Install farmOS 2.x. Install the farmOS modules you intend to use (this will determine what data is migrated). Add farmOS 1.x database connection info to settings.php : $databases['migrate']['default'] = [ 'database' => 'my_farmos_1x_db', 'username' => 'my-db-username', 'password' => 'my-db-password', 'prefix' => '', 'host' => 'localhost', 'port' => '3306', 'namespace' => 'Drupal\\\\Core\\\\Database\\\\Driver\\\\mysql', 'driver' => 'mysql', ]; Copy user-uploaded files to the new directory (see Migrating files below). Install the farmOS Migrate ( farm_migrate ) module. Run the farmOS 1.x Migrations via Drush (in this order): drush migrate:import --group=farm_migrate_config drush migrate:import --group=farm_migrate_role drush migrate:import --group=farm_migrate_user drush migrate:import --group=farm_migrate_file drush migrate:import --group=farm_migrate_taxonomy drush migrate:import --group=farm_migrate_asset drush migrate:import --group=farm_migrate_area drush migrate:import --group=farm_migrate_sensor_data drush migrate:import --group=farm_migrate_quantity drush migrate:import --group=farm_migrate_log drush migrate:import --group=farm_migrate_plan Confirm that all the above migrations were successful before running the final migration, which focuses only on populating the \"Parents\" field of assets. This migration cannot be rolled back (see Issue #3189740 ): drush migrate:import --group=farm_migrate_reference To view the status of all farmOS 1.x migrations: drush migrate:status --tag=\"farmOS 1.x\" After all migrations are complete, perform a thorough examination of data to confirm that nothing is missing or incorrect. The original 1.x database will not be touched during the migration, so if issues are discovered it can continue to be used as the canonical farmOS database until further testing and debugging can be performed. See Troubleshooting below for known issues. Please open bug reports in the farmOS issue queue if new issues are discovered. Migrating files \u00b6 farmOS allows files to be uploaded/attached to records. In order to migrate these files, they need to be copied into new site's files/private directories. The farmOS migration code will look for files in the following locations: Public files: public://migrate Private files: private://migrate The public:// and private:// prefixes map to the \"Public file system path\" and \"Private file system path\" configured in farmOS 1.x and 2.x at: /admin/config/media/file-system . This may vary for each installation. For example, if you have farmOS 1.x installed in /var/www/farmOS_1.x and farmOS 2.x in /var/www/farmOS_2.x , and both are configured to use sites/default/files for public files, and sites/default/private for private files, then copy the files as follows: cp -rp /var/www/farmOS_1.x/sites/default/files /var/www/farmOS_2.x/sites/default/files/migrate cp -rp /var/www/farmOS_1.x/sites/default/private/files /var/www/farmOS_2.x/sites/default/private/files/migrate The farmOS migration code will automatically move files from files/migrate/* to files/* . Only the files that it finds in the {file_managed} table will be moved, leaving behind various temporary files in the migrate directory that are no longer needed after the migration. This migrate directory can be deleted after the migration, once it has been confirmed that everything was migrated successfully. Limitations \u00b6 The farmOS migration code is designed to migrate a default farmOS 1.x database to 2.x. If any customizations have been made on top of the defaults, they will not be migrated. This includes (but is not limited to): Custom asset, entity, taxonomies, and log types Custom fields Custom roles If you maintain a contrib/custom module for farmOS 1.x, it is your responsibility to update the modules for 2.x and provide migration logic. Troubleshooting \u00b6 If an error occurs during migration, the status of the broken migration may be stuck as \"Importing\". In order to rerun the migration, first reset the status and then roll back the migration. Replace [migration_id] with ID of the migration that is stuck. drush migrate:reset-status [migration_id] drush migrate:rollback [migration_id] Movement logs \u00b6 farmOS 2.x changes the way asset movements are described via logs. There is a single \"Location reference\" and \"Geometry\" field on logs now, as opposed to the separate \"Move to\" and \"Movement geometry\" fields that existed in 1.x. The migration will use the movement area references and geometry if they are present, and will automatically mark the log as a movement. However, if the log has additional area references and geometry data, then the migration logic will detect the conflict and one of the following errors will be thrown: Log 123 has both area references and movement area references. Log 123 has both a geometry and a movement geometry. If these errors are encountered, the migration will halt and can not be completed until either: the logs in the old database are cleaned up, or the migration script is explicitly allowed to overwrite non-movement area references and geometry Manual clean up involves reviewing the logs that cause errors in the old database, deleting the \"Areas\" and \"Geometry\" fields (or copying them into the \"Move to\" and \"Movement geometry\" fields), and retrying the migration. In some cases it may make sense to split the log into two separate logs, in order to retain information. Alternatively, the migration script can be allowed to automatically overwrite the \"Areas\" and \"Geometry\" data from the log, and only keep the \"Move to\" and \"Movement geometry\" data. This can be configured by adding the following line to settings.php : $settings['farm_migrate_allow_movement_overwrite'] = TRUE; Beware that this may result in loss of data/context if the separate fields were being used intentionally. It is recommended that logs be reviewed manually to understand whether or not the data is needed. After running the migration with this setting, warnings for each log will be stored, and can be viewed with: drush migrate:messages [migration_id] Quantities \u00b6 The farmOS 2.x migration creates all Quantity entities before it creates the Log entities that reference them. This means that it is possible to end up with orphaned quantities, if for instance you do not migrate all of your log types from farmOS 1.x. There is no built-in way to clean these up currently, so it is recommended that all log types be migrated.","title":"1.x Migration"},{"location":"hosting/migration/#migrating-from-farmos-1x-to-2x","text":"The upgrade path from farmOS 1.x to 2.x is performed via a database migration. farmOS 2.x includes a farmOS Migrate module that leverage's Drupal core's Migrate API to provide migrations for each asset type, log type, etc. These migrations are defined in YML configuration files included with the farmOS Migrate module.","title":"Migrating from farmOS 1.x to 2.x"},{"location":"hosting/migration/#important-considerations","text":"Do not migrate into a farmOS 2.x instance that already has records. This is to ensure that the internal auto-incrementing IDs of records are maintained. Execute the migrations in the exact order they are shown below. It is especially important that all assets are migrated before any areas, because areas are converted to assets during the migration, which can cause ID conflicts/collisions. See Issue #3203228 Uploaded photos/files must be copied to the destination filesystem before migrating. See Migrating files below. See Limitations below.","title":"Important considerations"},{"location":"hosting/migration/#running-the-migration","text":"Follow the steps below to migrate your farmOS 1.x data to farmOS 2.x: Install farmOS 2.x. Install the farmOS modules you intend to use (this will determine what data is migrated). Add farmOS 1.x database connection info to settings.php : $databases['migrate']['default'] = [ 'database' => 'my_farmos_1x_db', 'username' => 'my-db-username', 'password' => 'my-db-password', 'prefix' => '', 'host' => 'localhost', 'port' => '3306', 'namespace' => 'Drupal\\\\Core\\\\Database\\\\Driver\\\\mysql', 'driver' => 'mysql', ]; Copy user-uploaded files to the new directory (see Migrating files below). Install the farmOS Migrate ( farm_migrate ) module. Run the farmOS 1.x Migrations via Drush (in this order): drush migrate:import --group=farm_migrate_config drush migrate:import --group=farm_migrate_role drush migrate:import --group=farm_migrate_user drush migrate:import --group=farm_migrate_file drush migrate:import --group=farm_migrate_taxonomy drush migrate:import --group=farm_migrate_asset drush migrate:import --group=farm_migrate_area drush migrate:import --group=farm_migrate_sensor_data drush migrate:import --group=farm_migrate_quantity drush migrate:import --group=farm_migrate_log drush migrate:import --group=farm_migrate_plan Confirm that all the above migrations were successful before running the final migration, which focuses only on populating the \"Parents\" field of assets. This migration cannot be rolled back (see Issue #3189740 ): drush migrate:import --group=farm_migrate_reference To view the status of all farmOS 1.x migrations: drush migrate:status --tag=\"farmOS 1.x\" After all migrations are complete, perform a thorough examination of data to confirm that nothing is missing or incorrect. The original 1.x database will not be touched during the migration, so if issues are discovered it can continue to be used as the canonical farmOS database until further testing and debugging can be performed. See Troubleshooting below for known issues. Please open bug reports in the farmOS issue queue if new issues are discovered.","title":"Running the migration"},{"location":"hosting/migration/#migrating-files","text":"farmOS allows files to be uploaded/attached to records. In order to migrate these files, they need to be copied into new site's files/private directories. The farmOS migration code will look for files in the following locations: Public files: public://migrate Private files: private://migrate The public:// and private:// prefixes map to the \"Public file system path\" and \"Private file system path\" configured in farmOS 1.x and 2.x at: /admin/config/media/file-system . This may vary for each installation. For example, if you have farmOS 1.x installed in /var/www/farmOS_1.x and farmOS 2.x in /var/www/farmOS_2.x , and both are configured to use sites/default/files for public files, and sites/default/private for private files, then copy the files as follows: cp -rp /var/www/farmOS_1.x/sites/default/files /var/www/farmOS_2.x/sites/default/files/migrate cp -rp /var/www/farmOS_1.x/sites/default/private/files /var/www/farmOS_2.x/sites/default/private/files/migrate The farmOS migration code will automatically move files from files/migrate/* to files/* . Only the files that it finds in the {file_managed} table will be moved, leaving behind various temporary files in the migrate directory that are no longer needed after the migration. This migrate directory can be deleted after the migration, once it has been confirmed that everything was migrated successfully.","title":"Migrating files"},{"location":"hosting/migration/#limitations","text":"The farmOS migration code is designed to migrate a default farmOS 1.x database to 2.x. If any customizations have been made on top of the defaults, they will not be migrated. This includes (but is not limited to): Custom asset, entity, taxonomies, and log types Custom fields Custom roles If you maintain a contrib/custom module for farmOS 1.x, it is your responsibility to update the modules for 2.x and provide migration logic.","title":"Limitations"},{"location":"hosting/migration/#troubleshooting","text":"If an error occurs during migration, the status of the broken migration may be stuck as \"Importing\". In order to rerun the migration, first reset the status and then roll back the migration. Replace [migration_id] with ID of the migration that is stuck. drush migrate:reset-status [migration_id] drush migrate:rollback [migration_id]","title":"Troubleshooting"},{"location":"hosting/migration/#movement-logs","text":"farmOS 2.x changes the way asset movements are described via logs. There is a single \"Location reference\" and \"Geometry\" field on logs now, as opposed to the separate \"Move to\" and \"Movement geometry\" fields that existed in 1.x. The migration will use the movement area references and geometry if they are present, and will automatically mark the log as a movement. However, if the log has additional area references and geometry data, then the migration logic will detect the conflict and one of the following errors will be thrown: Log 123 has both area references and movement area references. Log 123 has both a geometry and a movement geometry. If these errors are encountered, the migration will halt and can not be completed until either: the logs in the old database are cleaned up, or the migration script is explicitly allowed to overwrite non-movement area references and geometry Manual clean up involves reviewing the logs that cause errors in the old database, deleting the \"Areas\" and \"Geometry\" fields (or copying them into the \"Move to\" and \"Movement geometry\" fields), and retrying the migration. In some cases it may make sense to split the log into two separate logs, in order to retain information. Alternatively, the migration script can be allowed to automatically overwrite the \"Areas\" and \"Geometry\" data from the log, and only keep the \"Move to\" and \"Movement geometry\" data. This can be configured by adding the following line to settings.php : $settings['farm_migrate_allow_movement_overwrite'] = TRUE; Beware that this may result in loss of data/context if the separate fields were being used intentionally. It is recommended that logs be reviewed manually to understand whether or not the data is needed. After running the migration with this setting, warnings for each log will be stored, and can be viewed with: drush migrate:messages [migration_id]","title":"Movement logs"},{"location":"hosting/migration/#quantities","text":"The farmOS 2.x migration creates all Quantity entities before it creates the Log entities that reference them. This means that it is possible to end up with orphaned quantities, if for instance you do not migrate all of your log types from farmOS 1.x. There is no built-in way to clean these up currently, so it is recommended that all log types be migrated.","title":"Quantities"},{"location":"hosting/update/","text":"Updating farmOS \u00b6 ALWAYS BACKUP YOUR DATABASE, CODE, AND FILES BEFORE ATTEMPTING AN UPDATE! New versions of farmOS are released on a regular basis, and it's important to stay up-to-date so that you can receive new features, bug fixes, and security patches when they become available. Update procedure \u00b6 Backup your database and files! Always do this before updating. Be ready and able to roll-back in the event that something goes wrong. Typically this can be done by creating a database dump and a tarball of your web/sites directory. If you are using Docker, be sure you can roll back to the previous image version. If you are using packaged releases, be sure you also keep a copy of the old farmOS codebase before updating. Update the farmOS codebase. This will depend on how you have deployed farmOS. See Updating via Docker or Updating via packaged releases below for specific instructions. Run automated updates. Navigate to https://[hostname]/update.php in your browser and follow the steps to run automated updates. It is important to do this before using the new version of farmOS to ensure that any necessary changes to the database or configuration are made. Updating via Docker \u00b6 If you have deployed farmOS via Docker you can update to a new version of farmOS by pulling the new Docker image version: docker pull farmos/farmos:[version] This can also be done by updating your docker-compose.yml file if you are using Docker Compose and restarting your containers. Assuming that /opt/drupal/web/sites is the only directory persisted outside of the container, this will update the farmOS codebase, which is located in /opt/drupal within the container. See Persistence for more information. Updating via packaged releases \u00b6 If you have deployed farmOS via packaged releases you can update to a new version of farmOS by downloading the new release tarball and unpacking it in place of the old codebase, replacing everything except the web/sites directory. Be sure to replace (not merge ) all files and directories. Do not overwrite the web/sites directory, because it contains all your site-specific settings and uploaded files. Maintenance mode \u00b6 Optionally, you may put farmOS into \"maintenance mode\" to prevent users from accessing it during the update process. Navigate to https://[hostname]/admin/config/development/maintenance in your browser, enable maintenance mode, perform the update, confirm the new version works, then disable maintenance mode. If you are the only user of farmOS then this is not necessary, but be sure to run update.php before using the new version. Drush \u00b6 An alternative to running the automated updates by visiting update.php in your browser is to use the command-line tool Drush . The Drush command for running updates is: drush updb If you are running farmOS in Docker with the standard Docker Compose configuration, you can run this command inside the container with: docker-compose exec www drush updb Security releases \u00b6 When there are security updates released for farmOS dependency modules, you may see the following message: There is a security update available for your version of Drupal. To ensure the security of your server, you should update immediately! See the available updates page for more information. The farmOS maintainers will update these dependencies in the development branch of farmOS as soon as possible, and if the vulnerabilities affect farmOS directly a new version will be tagged and released. Many vulnerabilities are mitigated by the fact that farmOS is only accessible to users with a login. In those cases the maintainers may deem a release unnecessary. This message can disabled by uninstalling the \"Update Manager\" module.","title":"Updating"},{"location":"hosting/update/#updating-farmos","text":"ALWAYS BACKUP YOUR DATABASE, CODE, AND FILES BEFORE ATTEMPTING AN UPDATE! New versions of farmOS are released on a regular basis, and it's important to stay up-to-date so that you can receive new features, bug fixes, and security patches when they become available.","title":"Updating farmOS"},{"location":"hosting/update/#update-procedure","text":"Backup your database and files! Always do this before updating. Be ready and able to roll-back in the event that something goes wrong. Typically this can be done by creating a database dump and a tarball of your web/sites directory. If you are using Docker, be sure you can roll back to the previous image version. If you are using packaged releases, be sure you also keep a copy of the old farmOS codebase before updating. Update the farmOS codebase. This will depend on how you have deployed farmOS. See Updating via Docker or Updating via packaged releases below for specific instructions. Run automated updates. Navigate to https://[hostname]/update.php in your browser and follow the steps to run automated updates. It is important to do this before using the new version of farmOS to ensure that any necessary changes to the database or configuration are made.","title":"Update procedure"},{"location":"hosting/update/#updating-via-docker","text":"If you have deployed farmOS via Docker you can update to a new version of farmOS by pulling the new Docker image version: docker pull farmos/farmos:[version] This can also be done by updating your docker-compose.yml file if you are using Docker Compose and restarting your containers. Assuming that /opt/drupal/web/sites is the only directory persisted outside of the container, this will update the farmOS codebase, which is located in /opt/drupal within the container. See Persistence for more information.","title":"Updating via Docker"},{"location":"hosting/update/#updating-via-packaged-releases","text":"If you have deployed farmOS via packaged releases you can update to a new version of farmOS by downloading the new release tarball and unpacking it in place of the old codebase, replacing everything except the web/sites directory. Be sure to replace (not merge ) all files and directories. Do not overwrite the web/sites directory, because it contains all your site-specific settings and uploaded files.","title":"Updating via packaged releases"},{"location":"hosting/update/#maintenance-mode","text":"Optionally, you may put farmOS into \"maintenance mode\" to prevent users from accessing it during the update process. Navigate to https://[hostname]/admin/config/development/maintenance in your browser, enable maintenance mode, perform the update, confirm the new version works, then disable maintenance mode. If you are the only user of farmOS then this is not necessary, but be sure to run update.php before using the new version.","title":"Maintenance mode"},{"location":"hosting/update/#drush","text":"An alternative to running the automated updates by visiting update.php in your browser is to use the command-line tool Drush . The Drush command for running updates is: drush updb If you are running farmOS in Docker with the standard Docker Compose configuration, you can run this command inside the container with: docker-compose exec www drush updb","title":"Drush"},{"location":"hosting/update/#security-releases","text":"When there are security updates released for farmOS dependency modules, you may see the following message: There is a security update available for your version of Drupal. To ensure the security of your server, you should update immediately! See the available updates page for more information. The farmOS maintainers will update these dependencies in the development branch of farmOS as soon as possible, and if the vulnerabilities affect farmOS directly a new version will be tagged and released. Many vulnerabilities are mitigated by the fact that farmOS is only accessible to users with a login. In those cases the maintainers may deem a release unnecessary. This message can disabled by uninstalling the \"Update Manager\" module.","title":"Security releases"},{"location":"model/","text":"farmOS Data Model \u00b6 Goals \u00b6 The goal of the farmOS data model is to represent and organize a wide variety of agricultural and ecological systems to allow for easy access and analysis. This ranges from small-scale garden records to industrial agriculture to national forestry management. farmOS can model data that was recorded via manual data entry, as well as data streams from sensors or other applications. Record types \u00b6 Data is organized into a set of high-level record types. The two primary record keeping data types are Assets and Logs . Other types include Quantities , Terms , Plans , and Users . Assets Logs Quantities Terms Plans Users Logic \u00b6 Location Group membership Inventory Conventions \u00b6 Beyond the record types that farmOS provides, it is helpful to develop conventions around how they are used. farmOS Data Conventions","title":"Introduction"},{"location":"model/#farmos-data-model","text":"","title":"farmOS Data Model"},{"location":"model/#goals","text":"The goal of the farmOS data model is to represent and organize a wide variety of agricultural and ecological systems to allow for easy access and analysis. This ranges from small-scale garden records to industrial agriculture to national forestry management. farmOS can model data that was recorded via manual data entry, as well as data streams from sensors or other applications.","title":"Goals"},{"location":"model/#record-types","text":"Data is organized into a set of high-level record types. The two primary record keeping data types are Assets and Logs . Other types include Quantities , Terms , Plans , and Users . Assets Logs Quantities Terms Plans Users","title":"Record types"},{"location":"model/#logic","text":"Location Group membership Inventory","title":"Logic"},{"location":"model/#conventions","text":"Beyond the record types that farmOS provides, it is helpful to develop conventions around how they are used. farmOS Data Conventions","title":"Conventions"},{"location":"model/convention/","text":"Conventions \u00b6 In theory \u00b6 The farmOS data model describes basic record types that can be used to represent a farming system, but how those record types are used is left up to the user in large part. It is not the data model's responsibility to enforce an opinionated standard for all data that it stores. Instead, it aims to provide the flexibility for these standards to be developed through a collaborative community effort on top of the data model over time. These standards are collectively referred to as \"conventions\". Conventions are not part of the data model itself, but understanding how they relate to and are built on top of the model helps develop good record keeping habits, which result in more consistent and comparable data. One of the longer term goals of farmOS is to be a platform that supports the collaborative development of these conventions over time. As new standards are developed and adopted in the community, they can be written into modules that provide different levels of \"enforcement of\" or \"compliance to\" these conventions. The data model, combined with established conventions, and tools like the farmOS Aggregator can enable a wide variety of data sharing, aggregating, and reporting use-cases. In practice \u00b6 Within an individual farmOS instance, you may develop your own conventions around naming your Assets. Or you may develop a standard operating procedure for certain types of common data entry, to ensure that it always goes into farmOS in the same manner and format. Across separate farmOS instances, developing shared conventions enables data to be more easily aggregated and compared at larger scales. Some ways in which conventions are already being developed include: Quick forms, surveys, and other data entry tools that collect specific information and store it consistently in Logs. Reports that query the database for Logs that match a certain convention and summarize them in different ways.","title":"Conventions"},{"location":"model/convention/#conventions","text":"","title":"Conventions"},{"location":"model/convention/#in-theory","text":"The farmOS data model describes basic record types that can be used to represent a farming system, but how those record types are used is left up to the user in large part. It is not the data model's responsibility to enforce an opinionated standard for all data that it stores. Instead, it aims to provide the flexibility for these standards to be developed through a collaborative community effort on top of the data model over time. These standards are collectively referred to as \"conventions\". Conventions are not part of the data model itself, but understanding how they relate to and are built on top of the model helps develop good record keeping habits, which result in more consistent and comparable data. One of the longer term goals of farmOS is to be a platform that supports the collaborative development of these conventions over time. As new standards are developed and adopted in the community, they can be written into modules that provide different levels of \"enforcement of\" or \"compliance to\" these conventions. The data model, combined with established conventions, and tools like the farmOS Aggregator can enable a wide variety of data sharing, aggregating, and reporting use-cases.","title":"In theory"},{"location":"model/convention/#in-practice","text":"Within an individual farmOS instance, you may develop your own conventions around naming your Assets. Or you may develop a standard operating procedure for certain types of common data entry, to ensure that it always goes into farmOS in the same manner and format. Across separate farmOS instances, developing shared conventions enables data to be more easily aggregated and compared at larger scales. Some ways in which conventions are already being developed include: Quick forms, surveys, and other data entry tools that collect specific information and store it consistently in Logs. Reports that query the database for Logs that match a certain convention and summarize them in different ways.","title":"In practice"},{"location":"model/logic/group/","text":"Group membership \u00b6 farmOS includes an optional \"Group asset\" module, which adds a new Asset type called Group, as well as some organizational features that are unique to Group Assets. A Group can have \"members\", which are other individual Assets. Group membership is tracked via \"group assignment\" Logs. This is very similar to the way that Location works for \"movable\" Assets. This means that an Asset's group membership can change, and the full history of its previous memberships is maintained in Logs. A useful feature of Groups is that any Logs associated with the Group will also be associated with its member Assets. A common use case for this is tracking \"herds\" of Animal assets. Each herd can be represented as a Group Asset, with Animal Assets assigned to it. Logs can be used to move the whole group, instead of referencing Animal Assets individually. Notably, when the Group module is enabled, it overrides the Asset location logic to consider group membership. If the Asset is a member of a group, and the group has a movement Log that is more recent than any of the Asset's own movement Logs, then the Asset's location will be based on the group's Log. Group membership logic \u00b6 The logic for determining an Asset's group membership is as follows: Does the asset have a group assignment Log? Yes: Does the group assignment Log reference groups? Yes: groups referenced by the group assignment Log No: no group No: no group","title":"Group membership"},{"location":"model/logic/group/#group-membership","text":"farmOS includes an optional \"Group asset\" module, which adds a new Asset type called Group, as well as some organizational features that are unique to Group Assets. A Group can have \"members\", which are other individual Assets. Group membership is tracked via \"group assignment\" Logs. This is very similar to the way that Location works for \"movable\" Assets. This means that an Asset's group membership can change, and the full history of its previous memberships is maintained in Logs. A useful feature of Groups is that any Logs associated with the Group will also be associated with its member Assets. A common use case for this is tracking \"herds\" of Animal assets. Each herd can be represented as a Group Asset, with Animal Assets assigned to it. Logs can be used to move the whole group, instead of referencing Animal Assets individually. Notably, when the Group module is enabled, it overrides the Asset location logic to consider group membership. If the Asset is a member of a group, and the group has a movement Log that is more recent than any of the Asset's own movement Logs, then the Asset's location will be based on the group's Log.","title":"Group membership"},{"location":"model/logic/group/#group-membership-logic","text":"The logic for determining an Asset's group membership is as follows: Does the asset have a group assignment Log? Yes: Does the group assignment Log reference groups? Yes: groups referenced by the group assignment Log No: no group No: no group","title":"Group membership logic"},{"location":"model/logic/inventory/","text":"Inventory \u00b6 farmOS can track the inventory of Assets over time. Inventory is tracked via Logs with inventory adjustment Quantities . The Inventory module adds two fields to Quantity records: \"inventory asset\" and \"inventory adjustment\". Each Quantity can reference a single Asset, and either \"reset\", \"increment\", or \"decrement\" that Asset's inventory. The Quantity's \"measure\", \"value\", and \"units\" fields are used in the inventory calculations. Asset inventory is determined by querying all Quantities that reference the Asset and define an adjustment type of \"reset\", \"increment\", or \"decrement\". Inventory is calculated by adding all \"increment\" adjustments and subtracting all \"decrement\" adjustments, starting from the most recent \"reset\" adjustment (or zero if no \"reset\" adjustment exists). A separate inventory is tracked for each measure+unit pair, so Assets can have a single simple inventory (without a specified measure or unit), or they can have multiple inventories of different measures and units.","title":"Inventory"},{"location":"model/logic/inventory/#inventory","text":"farmOS can track the inventory of Assets over time. Inventory is tracked via Logs with inventory adjustment Quantities . The Inventory module adds two fields to Quantity records: \"inventory asset\" and \"inventory adjustment\". Each Quantity can reference a single Asset, and either \"reset\", \"increment\", or \"decrement\" that Asset's inventory. The Quantity's \"measure\", \"value\", and \"units\" fields are used in the inventory calculations. Asset inventory is determined by querying all Quantities that reference the Asset and define an adjustment type of \"reset\", \"increment\", or \"decrement\". Inventory is calculated by adding all \"increment\" adjustments and subtracting all \"decrement\" adjustments, starting from the most recent \"reset\" adjustment (or zero if no \"reset\" adjustment exists). A separate inventory is tracked for each measure+unit pair, so Assets can have a single simple inventory (without a specified measure or unit), or they can have multiple inventories of different measures and units.","title":"Inventory"},{"location":"model/logic/location/","text":"Location \u00b6 farmOS can track the physical location of Assets over time. This includes map geometry as well as relation to other Assets. Fixed Assets \u00b6 Some Assets are fixed in location. The geometry of these Assets is intrinsic to the Asset itself. Land is an example of an Asset with a fixed location. Although geography changes over time, land assets in farmOS should be considered a snapshot of the physical land they represent at the current time. This is useful because it provides a simplified model for referring to a logical piece of land and its geometry. Changes to a fixed Asset's intrinsic geometry should be limited to minor updates or corrections. If the changes are more substantial, a new Asset should be created, and the old Asset archived, to demarcate it as a new phase of the place in question. Movable Assets \u00b6 If an Asset is not fixed, then it is considered movable , and its location and geometry will be determined by movement Logs that reference it. In order to set or change a movable Asset's location, a movement Log must be created that defines its new location at that point in time. Any Log can be a movement. It just needs to reference the Assets that are moving, along with their new location. The new location can be in the form of a geometry and/or a reference to one or more location Assets. It is possible to find an Asset's location at any point in time by querying its movement Logs. Generally a movement Log is only included if it is \"done\", although it is also possible to find \"pending\" movement Logs in the future to find an Asset's projected future location. Locations \u00b6 Assets can be designated as locations . This allows other Assets to be moved to them. Typically, fixed Assets will also be designated as locations. However, movable Assets can also be locations. Consider a tractor (Equipment Asset) with multiple attachments (more Equipment Assets). It is possible to record that an attachment is connected to the tractor, and therefore its location is derived from the tractor's location. Fixed location Assets can designate parent Assets to create a hierarchical organization. Logic \u00b6 The logic for determining an Asset's geometry is as follows: Is the Asset fixed? Yes: Does it have an intrinsic geometry? Yes: intrinsic geometry No: no geometry No: Does it have a movement Log? Yes: Does the movement Log have geometry? Yes: movement Log geometry No: Does the movement Log reference a location Asset? Yes: (recurse to determine location Asset's geometry) No: no geometry No: no geometry Geometry \u00b6 When a Log is saved without a geometry, and it references locations that have geometries, the locations geometries will be copied to the Log.","title":"Location"},{"location":"model/logic/location/#location","text":"farmOS can track the physical location of Assets over time. This includes map geometry as well as relation to other Assets.","title":"Location"},{"location":"model/logic/location/#fixed-assets","text":"Some Assets are fixed in location. The geometry of these Assets is intrinsic to the Asset itself. Land is an example of an Asset with a fixed location. Although geography changes over time, land assets in farmOS should be considered a snapshot of the physical land they represent at the current time. This is useful because it provides a simplified model for referring to a logical piece of land and its geometry. Changes to a fixed Asset's intrinsic geometry should be limited to minor updates or corrections. If the changes are more substantial, a new Asset should be created, and the old Asset archived, to demarcate it as a new phase of the place in question.","title":"Fixed Assets"},{"location":"model/logic/location/#movable-assets","text":"If an Asset is not fixed, then it is considered movable , and its location and geometry will be determined by movement Logs that reference it. In order to set or change a movable Asset's location, a movement Log must be created that defines its new location at that point in time. Any Log can be a movement. It just needs to reference the Assets that are moving, along with their new location. The new location can be in the form of a geometry and/or a reference to one or more location Assets. It is possible to find an Asset's location at any point in time by querying its movement Logs. Generally a movement Log is only included if it is \"done\", although it is also possible to find \"pending\" movement Logs in the future to find an Asset's projected future location.","title":"Movable Assets"},{"location":"model/logic/location/#locations","text":"Assets can be designated as locations . This allows other Assets to be moved to them. Typically, fixed Assets will also be designated as locations. However, movable Assets can also be locations. Consider a tractor (Equipment Asset) with multiple attachments (more Equipment Assets). It is possible to record that an attachment is connected to the tractor, and therefore its location is derived from the tractor's location. Fixed location Assets can designate parent Assets to create a hierarchical organization.","title":"Locations"},{"location":"model/logic/location/#logic","text":"The logic for determining an Asset's geometry is as follows: Is the Asset fixed? Yes: Does it have an intrinsic geometry? Yes: intrinsic geometry No: no geometry No: Does it have a movement Log? Yes: Does the movement Log have geometry? Yes: movement Log geometry No: Does the movement Log reference a location Asset? Yes: (recurse to determine location Asset's geometry) No: no geometry No: no geometry","title":"Logic"},{"location":"model/logic/location/#geometry","text":"When a Log is saved without a geometry, and it references locations that have geometries, the locations geometries will be copied to the Log.","title":"Geometry"},{"location":"model/type/asset/","text":"Assets \u00b6 Assets represent the things that are being tracked or managed. Land, plants, animals, and equipment are all types of Assets. Modules can provide additional Asset types. Assets are generally limited in the information they contain. Most of the valuable historical information about an Asset will be stored in Logs that reference it. Type \u00b6 Each Asset must have a type. All Asset types have a common set of attributes and relationships. Specific Asset types may also add additional attributes and relationships (collectively referred to as \"fields\"). Asset types are defined by modules, and are only available if their module is enabled. The modules included with farmOS define the following Asset types: Land Plant Animal Equipment Compost Structure Sensor Water Group* *Group Assets are unique in that they can \"contain\" other Assets as \"group members\". This is a flexible feature that can be used for many purposes. One typical use case is representing \"herds\" of Animal Assets. Group membership changes are recorded via Logs (similar to location changes), so it is possible to see all the Groups that an Asset was a member of in the past, when/why they were moved, etc. See farmOS Group Membership Logic for more information. ID \u00b6 Each Asset will be assigned two unique IDs in the database: a universally unique identifier (UUID), and an internal numeric ID. The UUID will be unique across farmOS databases. The internal ID will only be unique to a single farmOS database. Therefore, the farmOS API uses UUIDs to ensure that IDs pulled from multiple farmOS databases do not conflict. Internally, farmOS modules use the internal IDs to perform CRUD operations. Attributes \u00b6 Assets have a number of attributes that serve to describe their meta information. All Assets have the same standard set of attributes. Modules can add additional attributes. Standard attributes \u00b6 Attributes that are common to all Asset types include: Name Status Flags Geometry Intrinsic geometry Is location Is fixed Notes ID Tags Data Name \u00b6 Assets must have a name that describes them. The name is used in lists of Assets to easily identify them at quick glance. Status \u00b6 Assets can be marked as \"active\" or \"archived\" to indicate their status. Archived Assets will be hidden from most lists in farmOS unless they are explicitly requested. Flags \u00b6 Flags can be added to Assets to help with sorting and filtering. farmOS provides a set of default flags, including \"Priority\", \"Needs review\", and \"Monitor\". Modules can provide additional flags, such as \"Organic\". Geometry \u00b6 The geometry of an Asset describes where it exists at a given point in time. An Asset can either be \"fixed\", or it can be moved around via movement Logs. This geometry field is not editable itself, but is rather computed based on the farmOS Location Logic . See related fields \"Intrinsic geometry\" and \"Is fixed\" below. Intrinsic geometry \u00b6 If an Asset is \"fixed\" in location (see \"Is fixed\" below), then it can have an \"intrinsic geometry\" to describe where it exists. This is only used if the Asset is designated as \"fixed\". Otherwise, its geometry and location are determined by movement Logs. For more information, see farmOS Location Logic . Is location \u00b6 An Asset can be designated as a \"location\" to indicate that other Assets may be moved to it using movement Logs. For more information, see farmOS Location Logic . Is fixed \u00b6 Assets can be designated as \"fixed\" to indicate that they do not move around in space and time. Examples of fixed Assets include land, buildings, water sources, fixed infrastructure such as pivot irrigation systems, etc. If an Asset is fixed, then it can have \"intrinsic geometry\" (see \"Intrinsic geometry\" above). Otherwise, its geometry and location can change over time, as determined by movement Logs. For more information, see farmOS Location Logic . Notes \u00b6 Notes can be added to an Asset to describe it in more detail. This is a freeform text field that allows a limited set of HTML tags, including links, lists, blockquotes, emphasis, etc. ID Tags \u00b6 Often an Asset will have ID tags associated with it. For example, an animal may have an RFID collar or an ear tag with a unique ID. ID tags in farmOS can store this ID, as well as its type and location. Data \u00b6 Assets have a hidden \"data\" field on them that is only accessible via the API. This provides a freeform plain text field that can be used to store additional data in any format (eg: JSON, YAML, XML). One use case for this field is to store remote system IDs that correspond to the Asset. So if the Asset is created or managed by software outside of farmOS, it can be identified easily. It can also be used to store additional structured metadata that does not fit into the standard Asset attributes. Additional attributes \u00b6 Assets may contain additional attributes: Inventory Inventory \u00b6 The inventory attribute summarizes current Asset inventory levels. This field is not editable itself, but is rather computed based on \"inventory adjustment\" logs. Each inventory can have a \"measure\", \"value\", and \"units\". For more information, see farmOS Inventory Logic . This field is added to all Asset types by default only if the Inventory module is enabled. Relationships \u00b6 Assets can be related to other records in farmOS These relationships are stored as reference fields on Asset records. All Assets have the same standard set of relationships. Modules can add additional relationships. Relationships that are common to all Asset types include: Location Parents Images Files Location \u00b6 Similar to the Asset \"Geometry\" field described above, an Asset's location describes where it is. Whereas the \"Geometry\" field contains raw geometry data (points, lines, and polygons), this field is a reference to one or more other Assets, which themselves are designated as \"locations\" (see \"Is location\" attribute above). If an Asset is designated as \"fixed\" then it can have an \"intrinsic geometry\" (see \"Intrinsic geometry\" above), but it will not have a location. For more information, see farmOS Location Logic . Parents \u00b6 Assets can specify \"Parent\" Assets that they descend from. This creates a lineage relationship that can be used to track breeding of Plant and Animal Assets. It can also be used to create more general hierarchical relationships between Assets such as representing a \"bed\" inside a \"field\" (represented by two Land Assets related through the Parents field). Multiple parents are allowed, but circular relationships are not. Images \u00b6 Images can be attached to Assets. This provides a place to store photos of the Asset. Files \u00b6 Files can be attached to Assets. This provides a place to put documents such as Shapefiles, PDFs, CSVs, or other files associated with the Asset. Additional relationships \u00b6 Assets may contain additional relationships: Group membership Group membership \u00b6 The group membership of an Asset references Group Assets which the Asset is a member of. This field is not editable itself, but is rather computed based on \"group assignment\" logs. For more information, see farmOS Group Membership Logic . This field is added to all Log types by default only if the Group module is enabled. Type-specific fields \u00b6 In addition to the fields that are common to all Asset types described above, some types add additional type-specific fields. These include: Animal Assets \u00b6 Animal Assets have the following additional attributes: Birthdate (timestamp) Is castrated (boolean) Nicknames (multiple strings) Sex (\"F\" or \"M\" string) And the following additional relationships: Animal type (References a Term in the \"Animal type\" vocabulary) Equipment Assets \u00b6 Equipment Assets have the following additional attributes: Manufacturer (string) Model (string) Serial number (string) Land Assets \u00b6 Land Assets have the following additional attributes: Land type (string) Plant Assets \u00b6 Plant Assets have the following additional relationships: Plant type (references a Term in the \"Plant type\" vocabulary) Season (references a Term in the \"Season\" vocabulary) Sensor Assets \u00b6 Sensor Assets have an additional \"Data streams\" relationship, which is used to reference Data Streams associated with the sensor. Structure Assets \u00b6 Structure Assets have the following additional attributes: Structure type (string)","title":"Assets"},{"location":"model/type/asset/#assets","text":"Assets represent the things that are being tracked or managed. Land, plants, animals, and equipment are all types of Assets. Modules can provide additional Asset types. Assets are generally limited in the information they contain. Most of the valuable historical information about an Asset will be stored in Logs that reference it.","title":"Assets"},{"location":"model/type/asset/#type","text":"Each Asset must have a type. All Asset types have a common set of attributes and relationships. Specific Asset types may also add additional attributes and relationships (collectively referred to as \"fields\"). Asset types are defined by modules, and are only available if their module is enabled. The modules included with farmOS define the following Asset types: Land Plant Animal Equipment Compost Structure Sensor Water Group* *Group Assets are unique in that they can \"contain\" other Assets as \"group members\". This is a flexible feature that can be used for many purposes. One typical use case is representing \"herds\" of Animal Assets. Group membership changes are recorded via Logs (similar to location changes), so it is possible to see all the Groups that an Asset was a member of in the past, when/why they were moved, etc. See farmOS Group Membership Logic for more information.","title":"Type"},{"location":"model/type/asset/#id","text":"Each Asset will be assigned two unique IDs in the database: a universally unique identifier (UUID), and an internal numeric ID. The UUID will be unique across farmOS databases. The internal ID will only be unique to a single farmOS database. Therefore, the farmOS API uses UUIDs to ensure that IDs pulled from multiple farmOS databases do not conflict. Internally, farmOS modules use the internal IDs to perform CRUD operations.","title":"ID"},{"location":"model/type/asset/#attributes","text":"Assets have a number of attributes that serve to describe their meta information. All Assets have the same standard set of attributes. Modules can add additional attributes.","title":"Attributes"},{"location":"model/type/asset/#standard-attributes","text":"Attributes that are common to all Asset types include: Name Status Flags Geometry Intrinsic geometry Is location Is fixed Notes ID Tags Data","title":"Standard attributes"},{"location":"model/type/asset/#name","text":"Assets must have a name that describes them. The name is used in lists of Assets to easily identify them at quick glance.","title":"Name"},{"location":"model/type/asset/#status","text":"Assets can be marked as \"active\" or \"archived\" to indicate their status. Archived Assets will be hidden from most lists in farmOS unless they are explicitly requested.","title":"Status"},{"location":"model/type/asset/#flags","text":"Flags can be added to Assets to help with sorting and filtering. farmOS provides a set of default flags, including \"Priority\", \"Needs review\", and \"Monitor\". Modules can provide additional flags, such as \"Organic\".","title":"Flags"},{"location":"model/type/asset/#geometry","text":"The geometry of an Asset describes where it exists at a given point in time. An Asset can either be \"fixed\", or it can be moved around via movement Logs. This geometry field is not editable itself, but is rather computed based on the farmOS Location Logic . See related fields \"Intrinsic geometry\" and \"Is fixed\" below.","title":"Geometry"},{"location":"model/type/asset/#intrinsic-geometry","text":"If an Asset is \"fixed\" in location (see \"Is fixed\" below), then it can have an \"intrinsic geometry\" to describe where it exists. This is only used if the Asset is designated as \"fixed\". Otherwise, its geometry and location are determined by movement Logs. For more information, see farmOS Location Logic .","title":"Intrinsic geometry"},{"location":"model/type/asset/#is-location","text":"An Asset can be designated as a \"location\" to indicate that other Assets may be moved to it using movement Logs. For more information, see farmOS Location Logic .","title":"Is location"},{"location":"model/type/asset/#is-fixed","text":"Assets can be designated as \"fixed\" to indicate that they do not move around in space and time. Examples of fixed Assets include land, buildings, water sources, fixed infrastructure such as pivot irrigation systems, etc. If an Asset is fixed, then it can have \"intrinsic geometry\" (see \"Intrinsic geometry\" above). Otherwise, its geometry and location can change over time, as determined by movement Logs. For more information, see farmOS Location Logic .","title":"Is fixed"},{"location":"model/type/asset/#notes","text":"Notes can be added to an Asset to describe it in more detail. This is a freeform text field that allows a limited set of HTML tags, including links, lists, blockquotes, emphasis, etc.","title":"Notes"},{"location":"model/type/asset/#id-tags","text":"Often an Asset will have ID tags associated with it. For example, an animal may have an RFID collar or an ear tag with a unique ID. ID tags in farmOS can store this ID, as well as its type and location.","title":"ID Tags"},{"location":"model/type/asset/#data","text":"Assets have a hidden \"data\" field on them that is only accessible via the API. This provides a freeform plain text field that can be used to store additional data in any format (eg: JSON, YAML, XML). One use case for this field is to store remote system IDs that correspond to the Asset. So if the Asset is created or managed by software outside of farmOS, it can be identified easily. It can also be used to store additional structured metadata that does not fit into the standard Asset attributes.","title":"Data"},{"location":"model/type/asset/#additional-attributes","text":"Assets may contain additional attributes: Inventory","title":"Additional attributes"},{"location":"model/type/asset/#inventory","text":"The inventory attribute summarizes current Asset inventory levels. This field is not editable itself, but is rather computed based on \"inventory adjustment\" logs. Each inventory can have a \"measure\", \"value\", and \"units\". For more information, see farmOS Inventory Logic . This field is added to all Asset types by default only if the Inventory module is enabled.","title":"Inventory"},{"location":"model/type/asset/#relationships","text":"Assets can be related to other records in farmOS These relationships are stored as reference fields on Asset records. All Assets have the same standard set of relationships. Modules can add additional relationships. Relationships that are common to all Asset types include: Location Parents Images Files","title":"Relationships"},{"location":"model/type/asset/#location","text":"Similar to the Asset \"Geometry\" field described above, an Asset's location describes where it is. Whereas the \"Geometry\" field contains raw geometry data (points, lines, and polygons), this field is a reference to one or more other Assets, which themselves are designated as \"locations\" (see \"Is location\" attribute above). If an Asset is designated as \"fixed\" then it can have an \"intrinsic geometry\" (see \"Intrinsic geometry\" above), but it will not have a location. For more information, see farmOS Location Logic .","title":"Location"},{"location":"model/type/asset/#parents","text":"Assets can specify \"Parent\" Assets that they descend from. This creates a lineage relationship that can be used to track breeding of Plant and Animal Assets. It can also be used to create more general hierarchical relationships between Assets such as representing a \"bed\" inside a \"field\" (represented by two Land Assets related through the Parents field). Multiple parents are allowed, but circular relationships are not.","title":"Parents"},{"location":"model/type/asset/#images","text":"Images can be attached to Assets. This provides a place to store photos of the Asset.","title":"Images"},{"location":"model/type/asset/#files","text":"Files can be attached to Assets. This provides a place to put documents such as Shapefiles, PDFs, CSVs, or other files associated with the Asset.","title":"Files"},{"location":"model/type/asset/#additional-relationships","text":"Assets may contain additional relationships: Group membership","title":"Additional relationships"},{"location":"model/type/asset/#group-membership","text":"The group membership of an Asset references Group Assets which the Asset is a member of. This field is not editable itself, but is rather computed based on \"group assignment\" logs. For more information, see farmOS Group Membership Logic . This field is added to all Log types by default only if the Group module is enabled.","title":"Group membership"},{"location":"model/type/asset/#type-specific-fields","text":"In addition to the fields that are common to all Asset types described above, some types add additional type-specific fields. These include:","title":"Type-specific fields"},{"location":"model/type/asset/#animal-assets","text":"Animal Assets have the following additional attributes: Birthdate (timestamp) Is castrated (boolean) Nicknames (multiple strings) Sex (\"F\" or \"M\" string) And the following additional relationships: Animal type (References a Term in the \"Animal type\" vocabulary)","title":"Animal Assets"},{"location":"model/type/asset/#equipment-assets","text":"Equipment Assets have the following additional attributes: Manufacturer (string) Model (string) Serial number (string)","title":"Equipment Assets"},{"location":"model/type/asset/#land-assets","text":"Land Assets have the following additional attributes: Land type (string)","title":"Land Assets"},{"location":"model/type/asset/#plant-assets","text":"Plant Assets have the following additional relationships: Plant type (references a Term in the \"Plant type\" vocabulary) Season (references a Term in the \"Season\" vocabulary)","title":"Plant Assets"},{"location":"model/type/asset/#sensor-assets","text":"Sensor Assets have an additional \"Data streams\" relationship, which is used to reference Data Streams associated with the sensor.","title":"Sensor Assets"},{"location":"model/type/asset/#structure-assets","text":"Structure Assets have the following additional attributes: Structure type (string)","title":"Structure Assets"},{"location":"model/type/data_stream/","text":"Data Streams \u00b6 Data Streams are records that represent sets of data streamed from sensors or other real-world devices. Type \u00b6 Each Data Stream must have a type. All Asset types have a common set of attributes and relationships. Specific Data Stream types may also add additional attributes and relationships (collectively referred to as \"fields\"). Data Stream types are defined by modules, and are only available if their module is enabled. The modules included with farmOS define the following Data Stream types: Basic Listener (Legacy) ID \u00b6 Each Data Stream will be assigned two unique IDs in the database: a universally unique identifier (UUID), and an internal numeric ID. The UUID will be unique across farmOS databases. The internal ID will only be unique to a single farmOS database. Therefore, the farmOS API uses UUIDs to ensure that IDs pulled from multiple farmOS databases do not conflict. Internally, farmOS modules use the internal IDs to perform CRUD operations. Attributes \u00b6 Data Streams have a number of attributes that serve to describe their meta information. All Data Stream have the same standard set of attributes. Modules can add additional attributes. Standard attributes \u00b6 Attributes that are common to all Data Stream types include: Name Private key Public Name \u00b6 Data Streams must have a name that describes them. The name is used in lists of Data Streams to easily identify them at quick glance. Private key \u00b6 A Data Stream's private key is the password used to post data to (and get data from) its API endpoint. Public \u00b6 A Data Stream may be marked as \"public\" to allow read-access from the API without a private key. This is useful for loading data into public third-party apps or scripts, for graphing or other purposes. Data Streams are not public by default. Relationships \u00b6 Data Streams can be related to other records in farmOS These relationships are stored as reference fields on Data Stream records. All Data Streams have the same standard set of relationships. Modules can add additional relationships. Relationships that are common to all Data Streams types include: Assets Assets \u00b6 Data Streams can reference one or more Assets to indicate that the data they collect is directly relevant to them. For example, if a soil moisture sensor that is installed in a field can be represented with a Sensor Asset (for the soil moisture sensor device itself), with a Data Stream (soil moisture data readings), that reference a Land Asset (the field it is installed in). This makes it possible for a single device to be moved/reused for monitoring multiple Assets, by moving the Sensor Asset and creating new Data Streams. Type-specific fields \u00b6 In addition to the fields that are common to all Data Stream types described above, some types add additional type-specific fields. These include: Basic Data Streams \u00b6 Basic Data Streams do not define any type-specific fields. Listener (Legacy) Data Streams \u00b6 Listener (Legacy) Data Streams have an additional \"public key\" attribute, which is used in the Data Stream's API endpoint for posting/getting data. This was used in farmOS 1.x to provide a unique ID for the sensor, separate from the Sensor Asset ID that housed the data. This is no longer needed in farmOS 2.x, because each Data Stream has its own UUID, which is used in the API endpoints instead. The public key is retained for Legacy (Listener) Data Streams to ensure that existing sensors can continue to push data without needing to be reconfigured.","title":"Data streams"},{"location":"model/type/data_stream/#data-streams","text":"Data Streams are records that represent sets of data streamed from sensors or other real-world devices.","title":"Data Streams"},{"location":"model/type/data_stream/#type","text":"Each Data Stream must have a type. All Asset types have a common set of attributes and relationships. Specific Data Stream types may also add additional attributes and relationships (collectively referred to as \"fields\"). Data Stream types are defined by modules, and are only available if their module is enabled. The modules included with farmOS define the following Data Stream types: Basic Listener (Legacy)","title":"Type"},{"location":"model/type/data_stream/#id","text":"Each Data Stream will be assigned two unique IDs in the database: a universally unique identifier (UUID), and an internal numeric ID. The UUID will be unique across farmOS databases. The internal ID will only be unique to a single farmOS database. Therefore, the farmOS API uses UUIDs to ensure that IDs pulled from multiple farmOS databases do not conflict. Internally, farmOS modules use the internal IDs to perform CRUD operations.","title":"ID"},{"location":"model/type/data_stream/#attributes","text":"Data Streams have a number of attributes that serve to describe their meta information. All Data Stream have the same standard set of attributes. Modules can add additional attributes.","title":"Attributes"},{"location":"model/type/data_stream/#standard-attributes","text":"Attributes that are common to all Data Stream types include: Name Private key Public","title":"Standard attributes"},{"location":"model/type/data_stream/#name","text":"Data Streams must have a name that describes them. The name is used in lists of Data Streams to easily identify them at quick glance.","title":"Name"},{"location":"model/type/data_stream/#private-key","text":"A Data Stream's private key is the password used to post data to (and get data from) its API endpoint.","title":"Private key"},{"location":"model/type/data_stream/#public","text":"A Data Stream may be marked as \"public\" to allow read-access from the API without a private key. This is useful for loading data into public third-party apps or scripts, for graphing or other purposes. Data Streams are not public by default.","title":"Public"},{"location":"model/type/data_stream/#relationships","text":"Data Streams can be related to other records in farmOS These relationships are stored as reference fields on Data Stream records. All Data Streams have the same standard set of relationships. Modules can add additional relationships. Relationships that are common to all Data Streams types include: Assets","title":"Relationships"},{"location":"model/type/data_stream/#assets","text":"Data Streams can reference one or more Assets to indicate that the data they collect is directly relevant to them. For example, if a soil moisture sensor that is installed in a field can be represented with a Sensor Asset (for the soil moisture sensor device itself), with a Data Stream (soil moisture data readings), that reference a Land Asset (the field it is installed in). This makes it possible for a single device to be moved/reused for monitoring multiple Assets, by moving the Sensor Asset and creating new Data Streams.","title":"Assets"},{"location":"model/type/data_stream/#type-specific-fields","text":"In addition to the fields that are common to all Data Stream types described above, some types add additional type-specific fields. These include:","title":"Type-specific fields"},{"location":"model/type/data_stream/#basic-data-streams","text":"Basic Data Streams do not define any type-specific fields.","title":"Basic Data Streams"},{"location":"model/type/data_stream/#listener-legacy-data-streams","text":"Listener (Legacy) Data Streams have an additional \"public key\" attribute, which is used in the Data Stream's API endpoint for posting/getting data. This was used in farmOS 1.x to provide a unique ID for the sensor, separate from the Sensor Asset ID that housed the data. This is no longer needed in farmOS 2.x, because each Data Stream has its own UUID, which is used in the API endpoints instead. The public key is retained for Legacy (Listener) Data Streams to ensure that existing sensors can continue to push data without needing to be reconfigured.","title":"Listener (Legacy) Data Streams"},{"location":"model/type/log/","text":"Logs \u00b6 Logs represent events, both active and passive. Observations, harvests, and inputs are all types of Logs. Modules can provide additional Log types. Type \u00b6 Each Log must have a type. All Log types have a common set of attributes and relationships. Specific Log types may also add additional attributes and relationships (collectively referred to as \"fields\"). Log types are defined by modules, and are only available if their module is enabled. The modules included with farmOS define the following Log types: Activity Observation Input Harvest Lab test Maintenance Medical Purchase Sale Seeding Transplanting ID \u00b6 Each Log will be assigned two unique IDs in the database: a universally unique identifier (UUID), and an internal numeric ID. The UUID will be unique across farmOS databases. The internal ID will only be unique to a single farmOS database. Therefore, the farmOS API uses UUIDs to ensure that IDs pulled from multiple farmOS databases do not conflict. Internally, farmOS modules use the internal IDs to perform CRUD operations. Attributes \u00b6 Logs have a number of attributes that serve to describe their meta information. All Logs have the same standard set of attributes. Modules can add additional attributes. Standard attributes \u00b6 Attributes that are common to all Log types include: Name Timestamp Status Flags Geometry Is movement Notes Data Name \u00b6 Logs must have a name that describes them. This will be automatically generated using a type-specific naming pattern if the Log is saved with an empty name. The name is used in lists of Logs to easily identify them at quick glance. Timestamp \u00b6 Logs always have a timestamp which indicates when they took place. Status \u00b6 Logs can be marked as \"pending\" or \"done\", to indicate whether they are \"planned\" or \"actual\" events. Every change that is made to a Log is stored as a revision, so that it's possible to see how a plan evolves over time until it eventually becomes a canonical record of the event that took place. Flags \u00b6 Flags can be added to Logs to help with sorting and filtering. farmOS provides a set of default flags, including \"Priority\", \"Needs review\", and \"Monitor\". Modules can provide additional flags, such as \"Organic\". Geometry \u00b6 Geometry data can be added to a Log to describe where it took place using points, lines, and polygons. When combined with the \"Is movement\" attribute (below), this will update the computed geometry of all Assets referenced on the Log. See the \"Geometry\" attribute of Assets . For more information, see farmOS Location Logic . Is movement \u00b6 A Log can be designated as a \"movement\" to indicate that any Assets referenced by it are being moved to the specified locations and/or geometry (see \"Geometry\" above and \"Locations\" below). If a Log is designated as a movement, and no location or geometry are defined, then the referenced Assets will no longer have a location or geometry. For more information, see farmOS Location Logic . Notes \u00b6 Notes can be added to a Log to describe it in more detail. This is a freeform text field that allows a limited set of HTML tags, including links, lists, blockquotes, emphasis, etc. Data \u00b6 Logs have a hidden \"data\" field on them that is only accessible via the API. This provides a freeform plain text field that can be used to store additional data in any format (eg: JSON, YAML, XML). One use case for this field is to store remote system IDs that correspond to the Log. So if the Log is created or managed by software outside of farmOS, it can be identified easily. It can also be used to store additional structured metadata that does not fit into the standard Log attributes. Additional attributes \u00b6 Logs may contain additional attributes: Is group assignment Is group assignment \u00b6 A log can be designated as a \"group assignment\" to indicate that any Assets referenced by it are being assigned to the referenced Group Assets (see \"Groups\" below). If a Log is designated as a group assignment, and no Group Assets are referenced, then the referenced Assets will no longer be members of a group. For more information, see farmOS Group Membership Logic . Relationships \u00b6 Logs can be related to the Assets and location(s) they pertain to. They can have quantitative data via related Quantities . They can be assigned to the Users who are responsible for them. And they can be organized using Terms and other metadata. These relationships are stored as reference fields on Logs. References are uni-directional, meaning that Logs reference Assets, but Assets do not reference Logs. It is possible to retrieve all Logs that reference a particular Asset, as well as retrieve all Assets referenced by a Log. All Logs have the same standard set of relationships. Modules can add additional relationships. Standard relationships \u00b6 Relationships that are common to all Log types include: Assets Locations Quantities Owners (whom the Log is assigned to) Categories Images Files Assets \u00b6 Logs can specify which Assets they pertain to. Over time, this builds a rich historical record of everything that has happened to a particular Asset. Locations \u00b6 Logs can reference Assets that are designated as \"locations\" to indicate where they took place. See the \"Is location\" attribute of Assets . When combined with the \"Is movement\" attribute (above), this will move all Assets referenced on the Log to the locations specified. For more information, see farmOS Location Logic . Quantities \u00b6 Quantities are records that contain quantitative data. These are used to represent things like input amounts, harvest totals, time tracking, etc. For more information, see: Quantities . Owners \u00b6 Logs can be assigned to one or more Users in farmOS. Categories \u00b6 Logs can be assigned to one or more categories to help with sorting and filtering. Categories differ from the \"Log Type\" in a few ways: A Log can be in multiple categories. Categories of a Log can change. The same set of Categories is available across all Log types. Categories are optional, type is required. Categories are therefore a more flexible and dynamic method of organizing sets of Logs, regardless of type. Categories differ from \"Flags\" in that categories only apply to Logs. Flags can be applied to Assets, Plans, and Logs. Flags are intended to bring attention to a Log, and are often highlighted in the UI. Flags may also be added and removed from a Log (eg: adding/removing the \"Needs review\" flag), whereas categories will tend to be fixed. Flags are also more strictly defined and controlled than categories. Categories are Terms in the \"Log categories\" vocabulary, so they can be added, edited, deleted, and rearranged through the UI. Flags must be defined in code by a module. Images \u00b6 Image can be attached to Logs. This provides a place to store photos associated with the task. Files \u00b6 Files can be attached to Logs. This provides a place to put documents such as Shapefiles, PDFs, CSVs, or other files associated with the task. Additional relationships \u00b6 Logs may contain additional relationships: Equipment used Groups Equipment used \u00b6 Logs can specify which Equipment Assets were used to perform a task. This differs from the Assets field (described above), which is for referencing the Assets that were the focus of the task. For example, if a Tractor is used to cultivate a field, the \"Equipment used\" field would reference the Tractor, and the \"Assets\" field would reference a Land Asset representing the field. This field is added to all Log types by default only if the Equipment module is enabled. Groups \u00b6 Logs can reference Group Assets, along with the \"Is group assignment\" attribute (above) to indicate which group(s) the Assets will be members of. This field is added to all Log types by default only if the Group module is enabled. For more information, see farmOS Membership Logic . Type-specific fields \u00b6 In addition to the fields that are common to all Log types described above, some types add additional type-specific fields. These include: Harvest Logs \u00b6 Harvest Logs have the following additional attributes: Lot number (string) Input Logs \u00b6 Input Logs have the following additional attributes: Lot number (string) Method (string) Purchase date (timestamp) Source (string) And the following additional relationships: Material (References Terms in the \"Material\" vocabulary) Lab Test Logs \u00b6 Lab Test Logs have the following additional attributes: Laboratory (string) Test type (string) Medical Logs \u00b6 Medical Logs have the following additional attributes: Veterinarian (string) Purchase Logs \u00b6 Purchase Logs have the following additional attributes: Invoice number (string) Seller (string) Lot number (string) Sale Logs \u00b6 Sale Logs have the following additional attributes: Customer (string) Invoice number (string) Lot number (string) Seeding Logs \u00b6 Seeding Logs have the following additional attributes: Lot number (string) Purchase date (timestamp) Source (string)","title":"Logs"},{"location":"model/type/log/#logs","text":"Logs represent events, both active and passive. Observations, harvests, and inputs are all types of Logs. Modules can provide additional Log types.","title":"Logs"},{"location":"model/type/log/#type","text":"Each Log must have a type. All Log types have a common set of attributes and relationships. Specific Log types may also add additional attributes and relationships (collectively referred to as \"fields\"). Log types are defined by modules, and are only available if their module is enabled. The modules included with farmOS define the following Log types: Activity Observation Input Harvest Lab test Maintenance Medical Purchase Sale Seeding Transplanting","title":"Type"},{"location":"model/type/log/#id","text":"Each Log will be assigned two unique IDs in the database: a universally unique identifier (UUID), and an internal numeric ID. The UUID will be unique across farmOS databases. The internal ID will only be unique to a single farmOS database. Therefore, the farmOS API uses UUIDs to ensure that IDs pulled from multiple farmOS databases do not conflict. Internally, farmOS modules use the internal IDs to perform CRUD operations.","title":"ID"},{"location":"model/type/log/#attributes","text":"Logs have a number of attributes that serve to describe their meta information. All Logs have the same standard set of attributes. Modules can add additional attributes.","title":"Attributes"},{"location":"model/type/log/#standard-attributes","text":"Attributes that are common to all Log types include: Name Timestamp Status Flags Geometry Is movement Notes Data","title":"Standard attributes"},{"location":"model/type/log/#name","text":"Logs must have a name that describes them. This will be automatically generated using a type-specific naming pattern if the Log is saved with an empty name. The name is used in lists of Logs to easily identify them at quick glance.","title":"Name"},{"location":"model/type/log/#timestamp","text":"Logs always have a timestamp which indicates when they took place.","title":"Timestamp"},{"location":"model/type/log/#status","text":"Logs can be marked as \"pending\" or \"done\", to indicate whether they are \"planned\" or \"actual\" events. Every change that is made to a Log is stored as a revision, so that it's possible to see how a plan evolves over time until it eventually becomes a canonical record of the event that took place.","title":"Status"},{"location":"model/type/log/#flags","text":"Flags can be added to Logs to help with sorting and filtering. farmOS provides a set of default flags, including \"Priority\", \"Needs review\", and \"Monitor\". Modules can provide additional flags, such as \"Organic\".","title":"Flags"},{"location":"model/type/log/#geometry","text":"Geometry data can be added to a Log to describe where it took place using points, lines, and polygons. When combined with the \"Is movement\" attribute (below), this will update the computed geometry of all Assets referenced on the Log. See the \"Geometry\" attribute of Assets . For more information, see farmOS Location Logic .","title":"Geometry"},{"location":"model/type/log/#is-movement","text":"A Log can be designated as a \"movement\" to indicate that any Assets referenced by it are being moved to the specified locations and/or geometry (see \"Geometry\" above and \"Locations\" below). If a Log is designated as a movement, and no location or geometry are defined, then the referenced Assets will no longer have a location or geometry. For more information, see farmOS Location Logic .","title":"Is movement"},{"location":"model/type/log/#notes","text":"Notes can be added to a Log to describe it in more detail. This is a freeform text field that allows a limited set of HTML tags, including links, lists, blockquotes, emphasis, etc.","title":"Notes"},{"location":"model/type/log/#data","text":"Logs have a hidden \"data\" field on them that is only accessible via the API. This provides a freeform plain text field that can be used to store additional data in any format (eg: JSON, YAML, XML). One use case for this field is to store remote system IDs that correspond to the Log. So if the Log is created or managed by software outside of farmOS, it can be identified easily. It can also be used to store additional structured metadata that does not fit into the standard Log attributes.","title":"Data"},{"location":"model/type/log/#additional-attributes","text":"Logs may contain additional attributes: Is group assignment","title":"Additional attributes"},{"location":"model/type/log/#is-group-assignment","text":"A log can be designated as a \"group assignment\" to indicate that any Assets referenced by it are being assigned to the referenced Group Assets (see \"Groups\" below). If a Log is designated as a group assignment, and no Group Assets are referenced, then the referenced Assets will no longer be members of a group. For more information, see farmOS Group Membership Logic .","title":"Is group assignment"},{"location":"model/type/log/#relationships","text":"Logs can be related to the Assets and location(s) they pertain to. They can have quantitative data via related Quantities . They can be assigned to the Users who are responsible for them. And they can be organized using Terms and other metadata. These relationships are stored as reference fields on Logs. References are uni-directional, meaning that Logs reference Assets, but Assets do not reference Logs. It is possible to retrieve all Logs that reference a particular Asset, as well as retrieve all Assets referenced by a Log. All Logs have the same standard set of relationships. Modules can add additional relationships.","title":"Relationships"},{"location":"model/type/log/#standard-relationships","text":"Relationships that are common to all Log types include: Assets Locations Quantities Owners (whom the Log is assigned to) Categories Images Files","title":"Standard relationships"},{"location":"model/type/log/#assets","text":"Logs can specify which Assets they pertain to. Over time, this builds a rich historical record of everything that has happened to a particular Asset.","title":"Assets"},{"location":"model/type/log/#locations","text":"Logs can reference Assets that are designated as \"locations\" to indicate where they took place. See the \"Is location\" attribute of Assets . When combined with the \"Is movement\" attribute (above), this will move all Assets referenced on the Log to the locations specified. For more information, see farmOS Location Logic .","title":"Locations"},{"location":"model/type/log/#quantities","text":"Quantities are records that contain quantitative data. These are used to represent things like input amounts, harvest totals, time tracking, etc. For more information, see: Quantities .","title":"Quantities"},{"location":"model/type/log/#owners","text":"Logs can be assigned to one or more Users in farmOS.","title":"Owners"},{"location":"model/type/log/#categories","text":"Logs can be assigned to one or more categories to help with sorting and filtering. Categories differ from the \"Log Type\" in a few ways: A Log can be in multiple categories. Categories of a Log can change. The same set of Categories is available across all Log types. Categories are optional, type is required. Categories are therefore a more flexible and dynamic method of organizing sets of Logs, regardless of type. Categories differ from \"Flags\" in that categories only apply to Logs. Flags can be applied to Assets, Plans, and Logs. Flags are intended to bring attention to a Log, and are often highlighted in the UI. Flags may also be added and removed from a Log (eg: adding/removing the \"Needs review\" flag), whereas categories will tend to be fixed. Flags are also more strictly defined and controlled than categories. Categories are Terms in the \"Log categories\" vocabulary, so they can be added, edited, deleted, and rearranged through the UI. Flags must be defined in code by a module.","title":"Categories"},{"location":"model/type/log/#images","text":"Image can be attached to Logs. This provides a place to store photos associated with the task.","title":"Images"},{"location":"model/type/log/#files","text":"Files can be attached to Logs. This provides a place to put documents such as Shapefiles, PDFs, CSVs, or other files associated with the task.","title":"Files"},{"location":"model/type/log/#additional-relationships","text":"Logs may contain additional relationships: Equipment used Groups","title":"Additional relationships"},{"location":"model/type/log/#equipment-used","text":"Logs can specify which Equipment Assets were used to perform a task. This differs from the Assets field (described above), which is for referencing the Assets that were the focus of the task. For example, if a Tractor is used to cultivate a field, the \"Equipment used\" field would reference the Tractor, and the \"Assets\" field would reference a Land Asset representing the field. This field is added to all Log types by default only if the Equipment module is enabled.","title":"Equipment used"},{"location":"model/type/log/#groups","text":"Logs can reference Group Assets, along with the \"Is group assignment\" attribute (above) to indicate which group(s) the Assets will be members of. This field is added to all Log types by default only if the Group module is enabled. For more information, see farmOS Membership Logic .","title":"Groups"},{"location":"model/type/log/#type-specific-fields","text":"In addition to the fields that are common to all Log types described above, some types add additional type-specific fields. These include:","title":"Type-specific fields"},{"location":"model/type/log/#harvest-logs","text":"Harvest Logs have the following additional attributes: Lot number (string)","title":"Harvest Logs"},{"location":"model/type/log/#input-logs","text":"Input Logs have the following additional attributes: Lot number (string) Method (string) Purchase date (timestamp) Source (string) And the following additional relationships: Material (References Terms in the \"Material\" vocabulary)","title":"Input Logs"},{"location":"model/type/log/#lab-test-logs","text":"Lab Test Logs have the following additional attributes: Laboratory (string) Test type (string)","title":"Lab Test Logs"},{"location":"model/type/log/#medical-logs","text":"Medical Logs have the following additional attributes: Veterinarian (string)","title":"Medical Logs"},{"location":"model/type/log/#purchase-logs","text":"Purchase Logs have the following additional attributes: Invoice number (string) Seller (string) Lot number (string)","title":"Purchase Logs"},{"location":"model/type/log/#sale-logs","text":"Sale Logs have the following additional attributes: Customer (string) Invoice number (string) Lot number (string)","title":"Sale Logs"},{"location":"model/type/log/#seeding-logs","text":"Seeding Logs have the following additional attributes: Lot number (string) Purchase date (timestamp) Source (string)","title":"Seeding Logs"},{"location":"model/type/plan/","text":"Plans \u00b6 Plans are higher-level records that organize Assets and Logs around a particular goal. Modules can provide Plan types, along with additional UI and logic for Assets and Logs that are managed by them. Type \u00b6 Each Plan must have a type. All Plan types have a common set of attributes and relationships. Specific Plan types may also add additional attributes and relationships (collectively referred to as \"fields\"). Plan types are defined by modules, and are only available if their module is enabled. farmOS core does not currently provide any Plan types. ID \u00b6 Each Plan will be assigned two unique IDs in the database: a universally unique identifier (UUID), and an internal numeric ID. The UUID will be unique across farmOS databases. The internal ID will only be unique to a single farmOS database. Therefore, the farmOS API uses UUIDs to ensure that IDs pulled from multiple farmOS databases do not conflict. Internally, farmOS modules use the internal IDs to perform CRUD operations. Attributes \u00b6 Plans have a number of attributes that serve to describe their meta information. All Plans have the same standard set of attributes. Modules can add additional attributes. Standard attributes \u00b6 Attributes that are common to all Plan types include: Name Status Flags Notes Data Name \u00b6 Plans must have a name that describes them. The name is used in lists of Plans to easily identify them at quick glance. Status \u00b6 Plans can be marked as \"active\" or \"archived\" to indicate their status. Archived Plans will be hidden from most lists in farmOS unless they are explicitly requested. Flags \u00b6 Flags can be added to Plans to help with sorting and filtering. farmOS provides a set of default flags, including \"Priority\", \"Needs review\", and \"Monitor\". Modules can provide additional flags, such as \"Organic\". Notes \u00b6 Notes can be added to a Plan to describe it in more detail. This is a freeform text field that allows a limited set of HTML tags, including links, lists, blockquotes, emphasis, etc. Data \u00b6 Plans have a hidden \"data\" field on them that is only accessible via the API. This provides a freeform plain text field that can be used to store additional data in any format (eg: JSON, YAML, XML). One use case for this field is to store remote system IDs that correspond to the Plan. So if the Plan is created or managed by software outside of farmOS, it can be identified easily. It can also be used to store additional structured metadata that does not fit into the standard Plan attributes. Relationships \u00b6 Plans can reference other record types (like Assets and Logs) that are \"part of the Plan\". These relationships can be simple (referencing the Asset/Log ID), or a Plan-type providing module can define more complex relationships by including other metadata alongside it. For example, a Crop Plan might reference a set of Plant Assets that represent the crops being grown in a particular season. Apart from just referencing the Plant Asset IDs, a Crop Plan may also reference specific Seeding and/or Transplanting Log IDs alongside those Plantings. It may also include attributes that are specific to the particular planning process that is being modelled. In addition to the Asset and Log IDs, perhaps a Crop Plan wants to store pieces of information like \"days to harvest\" or \"harvest window\" for each Plant Asset. These pieces of information do not belong on the Asset level itself, because they are specific to the Plan*. Therefore, they should be thought of as metadata of the relationship itself. Another example might be an Input Plan, that allows users to enter \"Target\" and \"Actual\" values for the amounts of a material that was applied. This Plan could create relationships to the Input Logs that it manages. The \"Actual\" quantity of material applied would be stored on the Input Log itself, but the \"Target\" is stored in the relationship between the Plan and the Log. * It is worth noting that some of this data may also be stored generally on Terms, and copied to the Plan when it is instantiated. For example: imagine a Crop/variety Term that has a \"days to harvest\" attribute on it, allowing you to define this as a system-wide default that is then copied into your Crop Plan when you create a new Plant Asset that references the Crop/variety Term. This allows the value to be overridden on the Plan+Asset level, in case conditions require it to. Standard relationships \u00b6 All Plans have the same standard set of relationships. Modules can add additional relationships. Relationships that are common to all Plan types include: Files Images Images \u00b6 Images can be attached to Plans. This provides a place to store photos that can be displayed alongside the Plan in farmOS. If the photos pertain to specific Assets or Logs within the Plan, it may be better to attach them to those records instead of the Plan. Files \u00b6 Files can be attached to Plans. This provides a place to put documents such as Shapefiles, PDFs, CSVs, or other files associated with the Plan. If the files pertain to specific Assets or Logs within the Plan, it may be better to attach them to those records instead of the Plan. Additional relationships \u00b6 Plans may contain additional relationships: Assets Logs However, the module that is providing the Plan type may decide to replace these with more advanced Asset/Log relationships if necessary. So the exact relationships may vary by Plan type. Assets \u00b6 Plans can reference Assets that are part of the Plan. Logs \u00b6 Plans can reference Logs that are part of the Plan.","title":"Plans"},{"location":"model/type/plan/#plans","text":"Plans are higher-level records that organize Assets and Logs around a particular goal. Modules can provide Plan types, along with additional UI and logic for Assets and Logs that are managed by them.","title":"Plans"},{"location":"model/type/plan/#type","text":"Each Plan must have a type. All Plan types have a common set of attributes and relationships. Specific Plan types may also add additional attributes and relationships (collectively referred to as \"fields\"). Plan types are defined by modules, and are only available if their module is enabled. farmOS core does not currently provide any Plan types.","title":"Type"},{"location":"model/type/plan/#id","text":"Each Plan will be assigned two unique IDs in the database: a universally unique identifier (UUID), and an internal numeric ID. The UUID will be unique across farmOS databases. The internal ID will only be unique to a single farmOS database. Therefore, the farmOS API uses UUIDs to ensure that IDs pulled from multiple farmOS databases do not conflict. Internally, farmOS modules use the internal IDs to perform CRUD operations.","title":"ID"},{"location":"model/type/plan/#attributes","text":"Plans have a number of attributes that serve to describe their meta information. All Plans have the same standard set of attributes. Modules can add additional attributes.","title":"Attributes"},{"location":"model/type/plan/#standard-attributes","text":"Attributes that are common to all Plan types include: Name Status Flags Notes Data","title":"Standard attributes"},{"location":"model/type/plan/#name","text":"Plans must have a name that describes them. The name is used in lists of Plans to easily identify them at quick glance.","title":"Name"},{"location":"model/type/plan/#status","text":"Plans can be marked as \"active\" or \"archived\" to indicate their status. Archived Plans will be hidden from most lists in farmOS unless they are explicitly requested.","title":"Status"},{"location":"model/type/plan/#flags","text":"Flags can be added to Plans to help with sorting and filtering. farmOS provides a set of default flags, including \"Priority\", \"Needs review\", and \"Monitor\". Modules can provide additional flags, such as \"Organic\".","title":"Flags"},{"location":"model/type/plan/#notes","text":"Notes can be added to a Plan to describe it in more detail. This is a freeform text field that allows a limited set of HTML tags, including links, lists, blockquotes, emphasis, etc.","title":"Notes"},{"location":"model/type/plan/#data","text":"Plans have a hidden \"data\" field on them that is only accessible via the API. This provides a freeform plain text field that can be used to store additional data in any format (eg: JSON, YAML, XML). One use case for this field is to store remote system IDs that correspond to the Plan. So if the Plan is created or managed by software outside of farmOS, it can be identified easily. It can also be used to store additional structured metadata that does not fit into the standard Plan attributes.","title":"Data"},{"location":"model/type/plan/#relationships","text":"Plans can reference other record types (like Assets and Logs) that are \"part of the Plan\". These relationships can be simple (referencing the Asset/Log ID), or a Plan-type providing module can define more complex relationships by including other metadata alongside it. For example, a Crop Plan might reference a set of Plant Assets that represent the crops being grown in a particular season. Apart from just referencing the Plant Asset IDs, a Crop Plan may also reference specific Seeding and/or Transplanting Log IDs alongside those Plantings. It may also include attributes that are specific to the particular planning process that is being modelled. In addition to the Asset and Log IDs, perhaps a Crop Plan wants to store pieces of information like \"days to harvest\" or \"harvest window\" for each Plant Asset. These pieces of information do not belong on the Asset level itself, because they are specific to the Plan*. Therefore, they should be thought of as metadata of the relationship itself. Another example might be an Input Plan, that allows users to enter \"Target\" and \"Actual\" values for the amounts of a material that was applied. This Plan could create relationships to the Input Logs that it manages. The \"Actual\" quantity of material applied would be stored on the Input Log itself, but the \"Target\" is stored in the relationship between the Plan and the Log. * It is worth noting that some of this data may also be stored generally on Terms, and copied to the Plan when it is instantiated. For example: imagine a Crop/variety Term that has a \"days to harvest\" attribute on it, allowing you to define this as a system-wide default that is then copied into your Crop Plan when you create a new Plant Asset that references the Crop/variety Term. This allows the value to be overridden on the Plan+Asset level, in case conditions require it to.","title":"Relationships"},{"location":"model/type/plan/#standard-relationships","text":"All Plans have the same standard set of relationships. Modules can add additional relationships. Relationships that are common to all Plan types include: Files Images","title":"Standard relationships"},{"location":"model/type/plan/#images","text":"Images can be attached to Plans. This provides a place to store photos that can be displayed alongside the Plan in farmOS. If the photos pertain to specific Assets or Logs within the Plan, it may be better to attach them to those records instead of the Plan.","title":"Images"},{"location":"model/type/plan/#files","text":"Files can be attached to Plans. This provides a place to put documents such as Shapefiles, PDFs, CSVs, or other files associated with the Plan. If the files pertain to specific Assets or Logs within the Plan, it may be better to attach them to those records instead of the Plan.","title":"Files"},{"location":"model/type/plan/#additional-relationships","text":"Plans may contain additional relationships: Assets Logs However, the module that is providing the Plan type may decide to replace these with more advanced Asset/Log relationships if necessary. So the exact relationships may vary by Plan type.","title":"Additional relationships"},{"location":"model/type/plan/#assets","text":"Plans can reference Assets that are part of the Plan.","title":"Assets"},{"location":"model/type/plan/#logs","text":"Plans can reference Logs that are part of the Plan.","title":"Logs"},{"location":"model/type/quantity/","text":"Quantities \u00b6 A Quantity in farmOS is a granular unit of quantitative data used to represent a single data point. Quantities do not exist on their own, but rather are created with and are referenced by Logs . Logs provide the supporting metadata to give context to the data stored in Quantities, including timestamp, location, relation to Assets , etc. Type \u00b6 Each Quantity must have a type. All Quantity types have a common set of attributes and relationships. Specific Quantity types (also called \"bundles\") may also add additional attributes and relationships (collectively referred to as \"fields\"). Quantity types are defined by modules, and are only available if their module is enabled. The modules included with farmOS define the following Quantity types: Standard Price ID \u00b6 Each Quantity will be assigned two unique IDs in the database: a universally unique identifier (UUID), and an internal numeric ID. The UUID will be unique across farmOS databases. The internal ID will only be unique to a single farmOS database. Therefore, the farmOS API uses UUIDs to ensure that IDs pulled from multiple farmOS databases do not conflict. Internally, farmOS modules use the internal IDs to perform CRUD operations. Attributes \u00b6 Quantities have a number of attributes that serve to describe their meta information. All Quantities have the same standard set of attributes. Modules can add additional attributes. Standard attributes \u00b6 Attributes that are common to all Quantity types include: Measure Value Label Measure \u00b6 The Measure attribute can be used to specify what type of measurement is being recorded. The available options are: Count Length/depth Weight Area Volume Time Temperature Pressure Water content Value Rate Rating Ratio Probability Value \u00b6 The Quantity value is a decimal number. Internally this is represented as two integers (numerator and denominator). Label \u00b6 A Quantity may have a label assigned to it. This helps to distinguish multiple Quantities of the same measure within a Log. Additional attributes \u00b6 Quantities may contain additional attributes: Inventory adjustment Inventory adjustment \u00b6 A Quantity can be designated as an \"inventory adjustment\" to reset, increment, or decrement the inventory of Assets referenced (see \"Inventory asset\" below). For more information, see farmOS Inventory Logic . Relationships \u00b6 All Quantities have the same standard set of relationships. Modules can add additional relationships. Standard relationships \u00b6 Relationships that are common to all Quantity types include: Unit Unit \u00b6 The Unit of measurement is stored as a Term in the Units vocabulary. Additional relationships \u00b6 Quantities may contain additional relationships: Inventory asset Inventory asset \u00b6 Quantities can reference Assets, along with the \"Inventory adjustment\" attribute (above) to record adjustments to the Asset's inventory. This field is added to all Quantity types by default only if the Inventory module is enabled. For more information, see farmOS Inventory Logic . Type-specific fields \u00b6 In addition to the fields that are common to all Quantity types described above, some types add additional type-specific fields. These include: Standard Quantities \u00b6 Standard Quantities do not define any type-specific fields. Price Quantities \u00b6 Price Quantities have additional \"Unit Price\" and \"Unit Quantity\" attributes, alongside the standard \"Value\" attribute. When these are used, the \"Value\" attribute is considered to be the total value (\"Unit Price\" multiplied by \"Unit Quantity\"). The \"Units\" of a Price Quantity will generally be a currency code such as \"USD\" or \"EUR\".","title":"Quantities"},{"location":"model/type/quantity/#quantities","text":"A Quantity in farmOS is a granular unit of quantitative data used to represent a single data point. Quantities do not exist on their own, but rather are created with and are referenced by Logs . Logs provide the supporting metadata to give context to the data stored in Quantities, including timestamp, location, relation to Assets , etc.","title":"Quantities"},{"location":"model/type/quantity/#type","text":"Each Quantity must have a type. All Quantity types have a common set of attributes and relationships. Specific Quantity types (also called \"bundles\") may also add additional attributes and relationships (collectively referred to as \"fields\"). Quantity types are defined by modules, and are only available if their module is enabled. The modules included with farmOS define the following Quantity types: Standard Price","title":"Type"},{"location":"model/type/quantity/#id","text":"Each Quantity will be assigned two unique IDs in the database: a universally unique identifier (UUID), and an internal numeric ID. The UUID will be unique across farmOS databases. The internal ID will only be unique to a single farmOS database. Therefore, the farmOS API uses UUIDs to ensure that IDs pulled from multiple farmOS databases do not conflict. Internally, farmOS modules use the internal IDs to perform CRUD operations.","title":"ID"},{"location":"model/type/quantity/#attributes","text":"Quantities have a number of attributes that serve to describe their meta information. All Quantities have the same standard set of attributes. Modules can add additional attributes.","title":"Attributes"},{"location":"model/type/quantity/#standard-attributes","text":"Attributes that are common to all Quantity types include: Measure Value Label","title":"Standard attributes"},{"location":"model/type/quantity/#measure","text":"The Measure attribute can be used to specify what type of measurement is being recorded. The available options are: Count Length/depth Weight Area Volume Time Temperature Pressure Water content Value Rate Rating Ratio Probability","title":"Measure"},{"location":"model/type/quantity/#value","text":"The Quantity value is a decimal number. Internally this is represented as two integers (numerator and denominator).","title":"Value"},{"location":"model/type/quantity/#label","text":"A Quantity may have a label assigned to it. This helps to distinguish multiple Quantities of the same measure within a Log.","title":"Label"},{"location":"model/type/quantity/#additional-attributes","text":"Quantities may contain additional attributes: Inventory adjustment","title":"Additional attributes"},{"location":"model/type/quantity/#inventory-adjustment","text":"A Quantity can be designated as an \"inventory adjustment\" to reset, increment, or decrement the inventory of Assets referenced (see \"Inventory asset\" below). For more information, see farmOS Inventory Logic .","title":"Inventory adjustment"},{"location":"model/type/quantity/#relationships","text":"All Quantities have the same standard set of relationships. Modules can add additional relationships.","title":"Relationships"},{"location":"model/type/quantity/#standard-relationships","text":"Relationships that are common to all Quantity types include: Unit","title":"Standard relationships"},{"location":"model/type/quantity/#unit","text":"The Unit of measurement is stored as a Term in the Units vocabulary.","title":"Unit"},{"location":"model/type/quantity/#additional-relationships","text":"Quantities may contain additional relationships: Inventory asset","title":"Additional relationships"},{"location":"model/type/quantity/#inventory-asset","text":"Quantities can reference Assets, along with the \"Inventory adjustment\" attribute (above) to record adjustments to the Asset's inventory. This field is added to all Quantity types by default only if the Inventory module is enabled. For more information, see farmOS Inventory Logic .","title":"Inventory asset"},{"location":"model/type/quantity/#type-specific-fields","text":"In addition to the fields that are common to all Quantity types described above, some types add additional type-specific fields. These include:","title":"Type-specific fields"},{"location":"model/type/quantity/#standard-quantities","text":"Standard Quantities do not define any type-specific fields.","title":"Standard Quantities"},{"location":"model/type/quantity/#price-quantities","text":"Price Quantities have additional \"Unit Price\" and \"Unit Quantity\" attributes, alongside the standard \"Value\" attribute. When these are used, the \"Value\" attribute is considered to be the total value (\"Unit Price\" multiplied by \"Unit Quantity\"). The \"Units\" of a Price Quantity will generally be a currency code such as \"USD\" or \"EUR\".","title":"Price Quantities"},{"location":"model/type/term/","text":"Terms \u00b6 Vocabularies (also referred to as taxonomies or ontologies) are used to organize and manage Terms used in various contexts throughout farmOS. These can be used for flagging, categorization, and organization of other record types. Most Terms in farmOS are user-defined, and the vocabularies are empty when farmOS is first installed. As Logs and Assets are created, Terms that are used to describe them are automatically generated in the appropriate vocabularies. These can then be used to filter records in the future. Type \u00b6 Each term must have a type, which is a reference to the vocabulary that it is in. Vocabularies are defined by modules, and are only available if their module is enabled. The modules included with farmOS define the following vocabularies: Animal type Log category Material Plant type Season Unit ID \u00b6 Each Term will be assigned two unique IDs in the database: a universally unique identifier (UUID), and an internal numeric ID. The UUID will be unique across farmOS databases. The internal ID will only be unique to a single farmOS database. Therefore, the farmOS API uses UUIDs to ensure that IDs pulled from multiple farmOS databases do not conflict. Internally, farmOS modules use the internal IDs to perform CRUD operations. Attributes \u00b6 Terms have a number of attributes that serve to describe their meta information. All Terms have the same standard set of attributes. Modules can add additional attributes. Standard attributes \u00b6 Attributes that are common to all Term types include: Name Description Weight Name \u00b6 Terms must have a name. Description \u00b6 Optionally, Terms may have a description. Weight \u00b6 The Term's weight determines how it is ordered in the vocabulary. See related \"Parent\" relationship below for organizing Terms into a hierarchy. Relationships \u00b6 All Terms have the same standard set of relationships. Modules can add additional relationships. Standard relationships \u00b6 Relationships that are common to all Term types include: Parent Parent \u00b6 Terms can specify \"Parent\" Terms to create a hierarchy. See related \"Weight\" attribute above for ordering Terms within the hierarchy. Type-specific fields \u00b6 In addition to the fields that are common to all Term types described above, some types add additional type-specific fields. These include: Plant Type Terms \u00b6 Terms in the \"Plant type\" vocabulary have the following additional attributes: Days to maturity (Integer) Days to transplant (Integer) And the following additional relationships: Companions (references other Terms in the \"Plant type\" vocabulary) Crop family (references a Term in the \"Crop Family\" vocabulary) Images (references uploaded image files)","title":"Terms"},{"location":"model/type/term/#terms","text":"Vocabularies (also referred to as taxonomies or ontologies) are used to organize and manage Terms used in various contexts throughout farmOS. These can be used for flagging, categorization, and organization of other record types. Most Terms in farmOS are user-defined, and the vocabularies are empty when farmOS is first installed. As Logs and Assets are created, Terms that are used to describe them are automatically generated in the appropriate vocabularies. These can then be used to filter records in the future.","title":"Terms"},{"location":"model/type/term/#type","text":"Each term must have a type, which is a reference to the vocabulary that it is in. Vocabularies are defined by modules, and are only available if their module is enabled. The modules included with farmOS define the following vocabularies: Animal type Log category Material Plant type Season Unit","title":"Type"},{"location":"model/type/term/#id","text":"Each Term will be assigned two unique IDs in the database: a universally unique identifier (UUID), and an internal numeric ID. The UUID will be unique across farmOS databases. The internal ID will only be unique to a single farmOS database. Therefore, the farmOS API uses UUIDs to ensure that IDs pulled from multiple farmOS databases do not conflict. Internally, farmOS modules use the internal IDs to perform CRUD operations.","title":"ID"},{"location":"model/type/term/#attributes","text":"Terms have a number of attributes that serve to describe their meta information. All Terms have the same standard set of attributes. Modules can add additional attributes.","title":"Attributes"},{"location":"model/type/term/#standard-attributes","text":"Attributes that are common to all Term types include: Name Description Weight","title":"Standard attributes"},{"location":"model/type/term/#name","text":"Terms must have a name.","title":"Name"},{"location":"model/type/term/#description","text":"Optionally, Terms may have a description.","title":"Description"},{"location":"model/type/term/#weight","text":"The Term's weight determines how it is ordered in the vocabulary. See related \"Parent\" relationship below for organizing Terms into a hierarchy.","title":"Weight"},{"location":"model/type/term/#relationships","text":"All Terms have the same standard set of relationships. Modules can add additional relationships.","title":"Relationships"},{"location":"model/type/term/#standard-relationships","text":"Relationships that are common to all Term types include: Parent","title":"Standard relationships"},{"location":"model/type/term/#parent","text":"Terms can specify \"Parent\" Terms to create a hierarchy. See related \"Weight\" attribute above for ordering Terms within the hierarchy.","title":"Parent"},{"location":"model/type/term/#type-specific-fields","text":"In addition to the fields that are common to all Term types described above, some types add additional type-specific fields. These include:","title":"Type-specific fields"},{"location":"model/type/term/#plant-type-terms","text":"Terms in the \"Plant type\" vocabulary have the following additional attributes: Days to maturity (Integer) Days to transplant (Integer) And the following additional relationships: Companions (references other Terms in the \"Plant type\" vocabulary) Crop family (references a Term in the \"Crop Family\" vocabulary) Images (references uploaded image files)","title":"Plant Type Terms"},{"location":"model/type/user/","text":"Users \u00b6 Users can log into farmOS with their own user accounts, each with a unique user name and email address. These accounts can be granted different roles, which include sets of permissions that give the user access to specific farmOS data and features. Logs can be assigned to Users.","title":"Users"},{"location":"model/type/user/#users","text":"Users can log into farmOS with their own user accounts, each with a unique user name and email address. These accounts can be granted different roles, which include sets of permissions that give the user access to specific farmOS data and features. Logs can be assigned to Users.","title":"Users"}]}