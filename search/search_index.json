{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"farmOS 2.x ATTENTION: This documentation is for the UNSTABLE 2.x branch of farmOS, which is under active development. If you want to use farmOS, the recommended stable branch is 7.x-1.x. Current documentation for 7.x-1.x is available at http://farmOS.org .","title":"farmOS"},{"location":"#farmos-2x","text":"ATTENTION: This documentation is for the UNSTABLE 2.x branch of farmOS, which is under active development. If you want to use farmOS, the recommended stable branch is 7.x-1.x. Current documentation for 7.x-1.x is available at http://farmOS.org .","title":"farmOS 2.x"},{"location":"api/","text":"API farmOS provides an API that other applications/systems can use to read and write records via HTTP requests. The root API endpoint is /api . farmOS adheres to the JSON:API specification, and JSON Schema is used to describe the available API resources. To begin exploring the farmOS API schema, visit /api/schema . From there, you can traverse a graph of interconnected schemas describing the entire API.","title":"Introduction"},{"location":"api/#api","text":"farmOS provides an API that other applications/systems can use to read and write records via HTTP requests. The root API endpoint is /api . farmOS adheres to the JSON:API specification, and JSON Schema is used to describe the available API resources. To begin exploring the farmOS API schema, visit /api/schema . From there, you can traverse a graph of interconnected schemas describing the entire API.","title":"API"},{"location":"api/changes/","text":"API Changes 2.x vs 1.x farmOS 1.x used the RESTful Web Services module, which provided API endpoints for each entity type (asset, log, taxonomy term, etc). farmOS 2.x uses the new JSON:API module included with Drupal core, which follows the JSON:API specification for defining API resources. The root API endpoint is /api . JSON Schema farmOS 2.x also provides JSON Schema information about all available resources. The root endpoint for schema information is /api/schema . In farmOS 1.x, the /farm.json endpoint provided similar information in the resources property. This has been removed in favor of JSON Schema. Endpoints In farmOS 1.x, API endpoints for each entity type were available at /[entity_type].json . For example: /log.json In farmOS 1.x, a root /api endpoint is provided, with a links object that describes all the available resource types and their endpoints. These follow a URL pattern of /api/[entity-type]/[bundle] . For example: /api/log/activity \"Bundles\" are \"sub-types\" that can have different sets (bundles) of fields on them. For example, a \"Seeding Log\" and a \"Harvest Log\" will collect different information, but both are \"Logs\" (events). To illustrate the difference between 1.x and 2.x, here are the endpoints for retrieving all Activity logs. farmOS 1.x: /log.json?type=farm_activity farmOS 2.x: /api/log/activity IDs farmOS 2.x assigns UUIDs (universally unique identifiers) to all resources, and uses them in the API. This differs from farmOS 1.x, which used the integer IDs directly from the auto-incrementing database table that the record was pulled from. The benefit of UUIDs is they are guaranteed to be unique across multiple farmOS databases, whereas the old IDs were not. The internal integer IDs are not exposed via the API, so all code that needs to integrate should use the new UUIDs instead. Also note that the migration from farmOS 1.x to 2.x does not preserve the internal integer IDs, so they may be different after migrating to 2.x. Record structure JSON:API has some rules about how records are structured that differ from farmOS 1.x. These rules make the API more explicit. In farmOS 1.x, all the fields/properties of a record were on the same level. For example, a simple observation log looked like this: { \"id\": \"5\" \"type\": \"farm_observation\", \"name\": \"Test observation\", \"timestamp\": \"1526584271\", \"asset\": [ { \"resource\": \"farm_asset\", \"id\": \"123\" } ] } In farmOS 2.x, JSON:API dictates that the \"attributes\" and \"relationships\" of a record be explicitly declared under attributes and relationships properties in the JSON. The same record in farmOS 2.x looks like: { \"id\": \"9bc49ffd-76e8-4f86-b811-b721cb771327\" \"type\": \"log--observation\", \"attributes\": { \"name\": \"Test observation\", \"timestamp\": \"1526584271\", }, \"relationships\": { \"asset\": { \"data\": [ { \"type\": \"asset--animal\", \"id\": \"75116e3e-c45e-431d-8b58-1fce6bb315cf\", } ] } } } Filtering The URL query parameters for filtering results have a different syntax in 2.x. Refer to the Drupal.org JSON:API Filtering documentation for more information. To illustrate, this is how to filter activity logs by their completed status: farmOS 1.x: /log.json?type=activity&done=1 farmOS 2.x: /api/log/activity?filter[status]=complete Logs Type names The farm_ prefix has been dropped from all log type names. For example, in farmOS 1.x an Activity log was farm_activity , and in farmOS 2.x it is simply activity . Additionally, the \"Soil test\" and \"Water test\" log types have been merged into a single \"Lab test\" log type. Below is the full list of log types in farmOS 1.x and their new names in 2.x: farm_activity -> activity farm_harvest -> harvest farm_input -> input farm_maintenance -> maintenance farm_medical -> medical farm_observation -> observation farm_purchase -> purchase farm_sale -> sale farm_seeding -> seeding farm_soil_test -> lab_test farm_transplanting -> transplanting farm_water_test -> lab_test Field names Log field names are largely unchanged, with a few exceptions (note that new fields are not listed here): date_purchase -> purchase_date done -> status (see \"Status\" below) files -> file flags -> flag geofield -> geometry images -> image input_method -> method input_source -> source log_category -> category log_owner -> owner seed_source -> source soil_lab -> lab water_lab -> lab Status In farmOS 1.x, logs had a boolean property called done which was either 1 (done) or 0 (not done). In 2.x, the done property has changed to status , and can be set to either done or pending . Additional states may be added in the future.","title":"Changes"},{"location":"api/changes/#api-changes","text":"","title":"API Changes"},{"location":"api/changes/#2x-vs-1x","text":"farmOS 1.x used the RESTful Web Services module, which provided API endpoints for each entity type (asset, log, taxonomy term, etc). farmOS 2.x uses the new JSON:API module included with Drupal core, which follows the JSON:API specification for defining API resources. The root API endpoint is /api .","title":"2.x vs 1.x"},{"location":"api/changes/#json-schema","text":"farmOS 2.x also provides JSON Schema information about all available resources. The root endpoint for schema information is /api/schema . In farmOS 1.x, the /farm.json endpoint provided similar information in the resources property. This has been removed in favor of JSON Schema.","title":"JSON Schema"},{"location":"api/changes/#endpoints","text":"In farmOS 1.x, API endpoints for each entity type were available at /[entity_type].json . For example: /log.json In farmOS 1.x, a root /api endpoint is provided, with a links object that describes all the available resource types and their endpoints. These follow a URL pattern of /api/[entity-type]/[bundle] . For example: /api/log/activity \"Bundles\" are \"sub-types\" that can have different sets (bundles) of fields on them. For example, a \"Seeding Log\" and a \"Harvest Log\" will collect different information, but both are \"Logs\" (events). To illustrate the difference between 1.x and 2.x, here are the endpoints for retrieving all Activity logs. farmOS 1.x: /log.json?type=farm_activity farmOS 2.x: /api/log/activity","title":"Endpoints"},{"location":"api/changes/#ids","text":"farmOS 2.x assigns UUIDs (universally unique identifiers) to all resources, and uses them in the API. This differs from farmOS 1.x, which used the integer IDs directly from the auto-incrementing database table that the record was pulled from. The benefit of UUIDs is they are guaranteed to be unique across multiple farmOS databases, whereas the old IDs were not. The internal integer IDs are not exposed via the API, so all code that needs to integrate should use the new UUIDs instead. Also note that the migration from farmOS 1.x to 2.x does not preserve the internal integer IDs, so they may be different after migrating to 2.x.","title":"IDs"},{"location":"api/changes/#record-structure","text":"JSON:API has some rules about how records are structured that differ from farmOS 1.x. These rules make the API more explicit. In farmOS 1.x, all the fields/properties of a record were on the same level. For example, a simple observation log looked like this: { \"id\": \"5\" \"type\": \"farm_observation\", \"name\": \"Test observation\", \"timestamp\": \"1526584271\", \"asset\": [ { \"resource\": \"farm_asset\", \"id\": \"123\" } ] } In farmOS 2.x, JSON:API dictates that the \"attributes\" and \"relationships\" of a record be explicitly declared under attributes and relationships properties in the JSON. The same record in farmOS 2.x looks like: { \"id\": \"9bc49ffd-76e8-4f86-b811-b721cb771327\" \"type\": \"log--observation\", \"attributes\": { \"name\": \"Test observation\", \"timestamp\": \"1526584271\", }, \"relationships\": { \"asset\": { \"data\": [ { \"type\": \"asset--animal\", \"id\": \"75116e3e-c45e-431d-8b58-1fce6bb315cf\", } ] } } }","title":"Record structure"},{"location":"api/changes/#filtering","text":"The URL query parameters for filtering results have a different syntax in 2.x. Refer to the Drupal.org JSON:API Filtering documentation for more information. To illustrate, this is how to filter activity logs by their completed status: farmOS 1.x: /log.json?type=activity&done=1 farmOS 2.x: /api/log/activity?filter[status]=complete","title":"Filtering"},{"location":"api/changes/#logs","text":"","title":"Logs"},{"location":"api/changes/#type-names","text":"The farm_ prefix has been dropped from all log type names. For example, in farmOS 1.x an Activity log was farm_activity , and in farmOS 2.x it is simply activity . Additionally, the \"Soil test\" and \"Water test\" log types have been merged into a single \"Lab test\" log type. Below is the full list of log types in farmOS 1.x and their new names in 2.x: farm_activity -> activity farm_harvest -> harvest farm_input -> input farm_maintenance -> maintenance farm_medical -> medical farm_observation -> observation farm_purchase -> purchase farm_sale -> sale farm_seeding -> seeding farm_soil_test -> lab_test farm_transplanting -> transplanting farm_water_test -> lab_test","title":"Type names"},{"location":"api/changes/#field-names","text":"Log field names are largely unchanged, with a few exceptions (note that new fields are not listed here): date_purchase -> purchase_date done -> status (see \"Status\" below) files -> file flags -> flag geofield -> geometry images -> image input_method -> method input_source -> source log_category -> category log_owner -> owner seed_source -> source soil_lab -> lab water_lab -> lab","title":"Field names"},{"location":"api/changes/#status","text":"In farmOS 1.x, logs had a boolean property called done which was either 1 (done) or 0 (not done). In 2.x, the done property has changed to status , and can be set to either done or pending . Additional states may be added in the future.","title":"Status"},{"location":"development/","text":"Getting started Follow these instructions to set up a local farmOS development environment. The only requirements are Docker and Docker Compose . 1. Set up Docker containers Run the following commands to create a farmOS directory and set up Docker containers for farmOS and PostgreSQL: mkdir farmOS && cd farmOS curl https://raw.githubusercontent.com/farmOS/farmOS/2.x/docker/docker-compose.development.yml -o docker-compose.yml sudo docker-compose up -d 2. Install farmOS Open http://localhost in a browser and install farmOS with the following database credentials: Database type: PostgreSQL Database name: farm Database user: farm Database password: farm Advanced options > Host: db 3. Develop Open the www directory in your favorite IDE. Optional Configure private filesystem In order to upload files, the following line must be added to www/web/sites/default/settings.php : $settings['file_private_path'] = 'sites/default/private/files'; Configure debugger See Debugging .","title":"Getting started"},{"location":"development/#getting-started","text":"Follow these instructions to set up a local farmOS development environment. The only requirements are Docker and Docker Compose .","title":"Getting started"},{"location":"development/#1-set-up-docker-containers","text":"Run the following commands to create a farmOS directory and set up Docker containers for farmOS and PostgreSQL: mkdir farmOS && cd farmOS curl https://raw.githubusercontent.com/farmOS/farmOS/2.x/docker/docker-compose.development.yml -o docker-compose.yml sudo docker-compose up -d","title":"1. Set up Docker containers"},{"location":"development/#2-install-farmos","text":"Open http://localhost in a browser and install farmOS with the following database credentials: Database type: PostgreSQL Database name: farm Database user: farm Database password: farm Advanced options > Host: db","title":"2. Install farmOS"},{"location":"development/#3-develop","text":"Open the www directory in your favorite IDE.","title":"3. Develop"},{"location":"development/#optional","text":"","title":"Optional"},{"location":"development/#configure-private-filesystem","text":"In order to upload files, the following line must be added to www/web/sites/default/settings.php : $settings['file_private_path'] = 'sites/default/private/files';","title":"Configure private filesystem"},{"location":"development/#configure-debugger","text":"See Debugging .","title":"Configure debugger"},{"location":"development/code/","text":"Coding standards farmOS follows Drupal coding standards . The farmOS development Docker image comes pre-installed with PHP CodeSniffer for detecting code standard violations. The following command will run PHP CodeSniffer on all farmOS code: sudo docker exec -it -u www-data farmos_www_1 phpcs /opt/drupal/web/profiles/farm If you see no output, then there are no issues. In some cases, code standard violations can be fixed automatically with phpcbf : sudo docker exec -it -u www-data farmos_www_1 phpcbf /opt/drupal/web/profiles/farm","title":"Coding standards"},{"location":"development/code/#coding-standards","text":"farmOS follows Drupal coding standards . The farmOS development Docker image comes pre-installed with PHP CodeSniffer for detecting code standard violations. The following command will run PHP CodeSniffer on all farmOS code: sudo docker exec -it -u www-data farmos_www_1 phpcs /opt/drupal/web/profiles/farm If you see no output, then there are no issues. In some cases, code standard violations can be fixed automatically with phpcbf : sudo docker exec -it -u www-data farmos_www_1 phpcbf /opt/drupal/web/profiles/farm","title":"Coding standards"},{"location":"development/composer/","text":"Composer The farmOS development Docker image comes pre-installed with Composer , which is used for dependency management. Running Composer in Docker In order to run the composer command, you must use docker exec to run the command inside the farmOS container. sudo docker exec -it -u www-data farmos_www_1 composer For example, the following will run the composer help command: sudo docker exec -it -u www-data farmos_www_1 composer help Common tasks Some common Composer tasks are documented here. Updating dependencies composer update [package-name] Warning : If composer update farmos/farmos is run, it will replace the Git repository in web/profiles/farm , discarding all changes/branches/remotes/etc. Adding a module composer require drupal/[module] This will download the module into the web/modules/contrib directory, and add it to the root composer.json file. If the module is being added to the farmOS installation profile itself, you need to manually move the require line from the root composer.json to web/profiles/farm/composer.json and commit it to that repository. To install the module, use Drush . Notes Could not delete /var/www/html/web/sites/default/default.settings.php See https://www.drupal.org/docs/develop/using-composer/starting-a-site-using-drupal-composer-project-templates#s-troubleshooting-permission-issues-prevent-running-composer","title":"Composer"},{"location":"development/composer/#composer","text":"The farmOS development Docker image comes pre-installed with Composer , which is used for dependency management.","title":"Composer"},{"location":"development/composer/#running-composer-in-docker","text":"In order to run the composer command, you must use docker exec to run the command inside the farmOS container. sudo docker exec -it -u www-data farmos_www_1 composer For example, the following will run the composer help command: sudo docker exec -it -u www-data farmos_www_1 composer help","title":"Running Composer in Docker"},{"location":"development/composer/#common-tasks","text":"Some common Composer tasks are documented here.","title":"Common tasks"},{"location":"development/composer/#updating-dependencies","text":"composer update [package-name] Warning : If composer update farmos/farmos is run, it will replace the Git repository in web/profiles/farm , discarding all changes/branches/remotes/etc.","title":"Updating dependencies"},{"location":"development/composer/#adding-a-module","text":"composer require drupal/[module] This will download the module into the web/modules/contrib directory, and add it to the root composer.json file. If the module is being added to the farmOS installation profile itself, you need to manually move the require line from the root composer.json to web/profiles/farm/composer.json and commit it to that repository. To install the module, use Drush .","title":"Adding a module"},{"location":"development/composer/#notes","text":"Could not delete /var/www/html/web/sites/default/default.settings.php See https://www.drupal.org/docs/develop/using-composer/starting-a-site-using-drupal-composer-project-templates#s-troubleshooting-permission-issues-prevent-running-composer","title":"Notes"},{"location":"development/debug/","text":"Debugging The farmOS development Docker image comes pre-installed with XDebug . In order to connect to it, the XDEBUG_CONFIG environment variable must be used to configure XDebug's remote_host setting with the Docker container's \"Gateway\" IP address. With the containers running, this command will print the gateway IP: sudo docker inspect farmos_www_1 | grep -o '\"Gateway\": \".*\\..*\\..*\\..*\"' Edit docker-compose.yml and enter the gateway IP in the XDEBUG_CONFIG environment variable. For example: environment: XDEBUG_CONFIG: remote_host=192.168.128.1 Restart the Docker containers for this change to take affect. sudo docker-compose restart Note : If the Docker containers are removed and recreated, the IP address may change, and you will need to repeat these steps to reconfigure it.","title":"Debugging"},{"location":"development/debug/#debugging","text":"The farmOS development Docker image comes pre-installed with XDebug . In order to connect to it, the XDEBUG_CONFIG environment variable must be used to configure XDebug's remote_host setting with the Docker container's \"Gateway\" IP address. With the containers running, this command will print the gateway IP: sudo docker inspect farmos_www_1 | grep -o '\"Gateway\": \".*\\..*\\..*\\..*\"' Edit docker-compose.yml and enter the gateway IP in the XDEBUG_CONFIG environment variable. For example: environment: XDEBUG_CONFIG: remote_host=192.168.128.1 Restart the Docker containers for this change to take affect. sudo docker-compose restart Note : If the Docker containers are removed and recreated, the IP address may change, and you will need to repeat these steps to reconfigure it.","title":"Debugging"},{"location":"development/docker/","text":"Docker Docker build arguments The farmOS Docker images allow certain variables to be overridden at image build time using the --build-arg parameter of docker build . Available arguments and their default values are described below: FARMOS_REPO - The farmOS Git repository URL. Default: https://github.com/farmOS/farmOS.git FARMOS_VERSION - The farmOS Git branch/tag/commit to check out. Default: 2.x PROJECT_REPO - The farmOS Composer project Git repository URL. Default: https://github.com/farmOS/composer-project.git PROJECT_VERSION - The farmOS Composer project Git branch/tag/commit to check out. Default: 2.x The 2.x-dev image also provides the following: WWW_DATA_ID - The ID to use for the www-data user and group inside the image. Setting this to the ID of the developer's user on the host machine allows Composer to create files owned by www-data inside the container, while keeping those files editable by the developer outside of the container. If your user ID is not 1000 , build the image with: --build-arg WWW_DATA_ID=$(id -u) Default: 1000","title":"Docker"},{"location":"development/docker/#docker","text":"","title":"Docker"},{"location":"development/docker/#docker-build-arguments","text":"The farmOS Docker images allow certain variables to be overridden at image build time using the --build-arg parameter of docker build . Available arguments and their default values are described below: FARMOS_REPO - The farmOS Git repository URL. Default: https://github.com/farmOS/farmOS.git FARMOS_VERSION - The farmOS Git branch/tag/commit to check out. Default: 2.x PROJECT_REPO - The farmOS Composer project Git repository URL. Default: https://github.com/farmOS/composer-project.git PROJECT_VERSION - The farmOS Composer project Git branch/tag/commit to check out. Default: 2.x The 2.x-dev image also provides the following: WWW_DATA_ID - The ID to use for the www-data user and group inside the image. Setting this to the ID of the developer's user on the host machine allows Composer to create files owned by www-data inside the container, while keeping those files editable by the developer outside of the container. If your user ID is not 1000 , build the image with: --build-arg WWW_DATA_ID=$(id -u) Default: 1000","title":"Docker build arguments"},{"location":"development/drush/","text":"Drush The farmOS Docker image comes pre-installed with Drush , which provides shell commands for working with a Drupal installation. Running Drush in Docker In order to run the drush command, you must use docker exec to run the command inside the farmOS container. sudo docker exec -it -u www-data farmos_www_1 drush For example, the following will run the drush cr command to rebuild caches: sudo docker exec -it -u www-data farmos_www_1 drush cr Useful commands Some useful Drush commands are documented here. Rebuild caches drush cr Install a module drush en log","title":"Drush"},{"location":"development/drush/#drush","text":"The farmOS Docker image comes pre-installed with Drush , which provides shell commands for working with a Drupal installation.","title":"Drush"},{"location":"development/drush/#running-drush-in-docker","text":"In order to run the drush command, you must use docker exec to run the command inside the farmOS container. sudo docker exec -it -u www-data farmos_www_1 drush For example, the following will run the drush cr command to rebuild caches: sudo docker exec -it -u www-data farmos_www_1 drush cr","title":"Running Drush in Docker"},{"location":"development/drush/#useful-commands","text":"Some useful Drush commands are documented here.","title":"Useful commands"},{"location":"development/drush/#rebuild-caches","text":"drush cr","title":"Rebuild caches"},{"location":"development/drush/#install-a-module","text":"drush en log","title":"Install a module"},{"location":"development/postgresql/","text":"PostgreSQL The farmOS Docker image comes pre-installed with the PostgreSQL client psql command, which can be used to connect to the database and run queries from the command line. Open PostgreSQL prompt sudo docker exec -it farmos_www_1 psql -h db -d farm -U farm Enter farm as the password.","title":"PostgreSQL"},{"location":"development/postgresql/#postgresql","text":"The farmOS Docker image comes pre-installed with the PostgreSQL client psql command, which can be used to connect to the database and run queries from the command line.","title":"PostgreSQL"},{"location":"development/postgresql/#open-postgresql-prompt","text":"sudo docker exec -it farmos_www_1 psql -h db -d farm -U farm Enter farm as the password.","title":"Open PostgreSQL prompt"},{"location":"development/tests/","text":"Automated tests The farmOS development Docker image comes pre-installed with all the dependencies necessary for running automated tests via PHPUnit . The following command will run all automated tests provided by farmOS: sudo docker exec -it -u www-data farmos_www_1 phpunit --verbose --debug --group farm Tests from other projects/dependencies can be run in a similar fashion. For example, the following command will run all tests in the Log module: sudo docker exec -it -u www-data farmos_www_1 phpunit --verbose --debug --group Log","title":"Automated tests"},{"location":"development/tests/#automated-tests","text":"The farmOS development Docker image comes pre-installed with all the dependencies necessary for running automated tests via PHPUnit . The following command will run all automated tests provided by farmOS: sudo docker exec -it -u www-data farmos_www_1 phpunit --verbose --debug --group farm Tests from other projects/dependencies can be run in a similar fashion. For example, the following command will run all tests in the Log module: sudo docker exec -it -u www-data farmos_www_1 phpunit --verbose --debug --group Log","title":"Automated tests"},{"location":"migration/","text":"Migrating from farmOS 1.x to 2.x Install farmOS 2.x. Install the farmOS modules you intend to use (this will determine what data is migrated). Add farmOS 1.x database connection info to settings.php : $databases['migrate']['default'] = [ 'database' => 'my_farmos_1x_db', 'username' => 'my-db-username', 'password' => 'my-db-password', 'prefix' => '', 'host' => 'localhost', 'port' => '3306', 'namespace' => 'Drupal\\\\Core\\\\Database\\\\Driver\\\\mysql', 'driver' => 'mysql', ]; Install the farmOS Migrate ( farm_migrate ) module. Run the farmOS 1.x Migration via Drush: drush migrate:import --group=farm_migrate Limitations The farmOS migration code is designed to migrate a default farmOS 1.x database to 2.x. If any customizations have been made on top of the defaults, they will not be migrated. This includes (but is not limited to): Custom asset, entity, taxonomies, and log types Custom fields Custom roles If you maintain a contrib/custom module for farmOS 1.x, it is your responsibility to update the modules for 2.x and provide migration logic.","title":"Overview"},{"location":"migration/#migrating-from-farmos-1x-to-2x","text":"Install farmOS 2.x. Install the farmOS modules you intend to use (this will determine what data is migrated). Add farmOS 1.x database connection info to settings.php : $databases['migrate']['default'] = [ 'database' => 'my_farmos_1x_db', 'username' => 'my-db-username', 'password' => 'my-db-password', 'prefix' => '', 'host' => 'localhost', 'port' => '3306', 'namespace' => 'Drupal\\\\Core\\\\Database\\\\Driver\\\\mysql', 'driver' => 'mysql', ]; Install the farmOS Migrate ( farm_migrate ) module. Run the farmOS 1.x Migration via Drush: drush migrate:import --group=farm_migrate","title":"Migrating from farmOS 1.x to 2.x"},{"location":"migration/#limitations","text":"The farmOS migration code is designed to migrate a default farmOS 1.x database to 2.x. If any customizations have been made on top of the defaults, they will not be migrated. This includes (but is not limited to): Custom asset, entity, taxonomies, and log types Custom fields Custom roles If you maintain a contrib/custom module for farmOS 1.x, it is your responsibility to update the modules for 2.x and provide migration logic.","title":"Limitations"}]}